### This file created by IYACC 1.0
### Please send bug reports to raypereda@hotmail.com
#define YYPREFIX "yy"
#line 1 "calc.y"
## add any special linking stuff here
global vars
 
#line 8 "calc.icn"
$define NUM 257
$define NAME 258
$define ASSIGNMENT 259
$define NEG 260
$define YYERRCODE 256
procedure init() 
  yylhs := [                                        -1,
    0,    0,    1,    1,    1,    2,    2,    2,    2,    2,
    2,    2,    2,    2,
  ]
  yylen := [                            2,
    0,    2,    1,    2,    4,    1,    1,    3,    3,    3,
    3,    2,    3,    3,
  ]
  yydefred := [                         1,
    0,    6,    0,    0,    3,    0,    2,    0,    0,    7,
    0,    0,    0,    0,    0,    0,    0,    4,    0,   14,
    0,    0,    0,    0,    0,    5,
  ]
  yydgoto := [                          1,
    7,    8,
  ]
  yysindex := [                         0,
  -10,    0, -257,  -39,    0,  -39,    0,   -6,  -39,    0,
  -91,  -33,  -39,  -39,  -39,  -39,  -39,    0,    1,    0,
  -29,  -29,  -91,  -91,  -91,    0,
  ]
  yyrindex := [                         0,
    0,    0,    7,    0,    0,    0,    0,    0,    0,    0,
   15,    0,    0,    0,    0,    0,    0,    0,    0,    0,
   10,   23,   28,   35,   49,    0,
  ]
  yygindex := [                         0,
    0,   93,
  ]
$define YYTABLESIZE 248
  yytable := [                          5,
    6,    9,   17,   18,    0,    4,    0,   20,   15,   14,
   26,   13,   15,   16,    0,    0,    7,   16,    0,    9,
    0,    0,    0,    0,   12,    0,    0,    0,    0,    6,
    0,    0,    8,    0,    4,   15,   14,   10,   13,    0,
   16,    0,   15,   14,   11,   13,    0,   16,    7,    7,
    9,    7,    9,    7,    9,   12,   12,   12,   13,   12,
   17,   12,    0,    8,   17,    8,    0,    8,   10,   10,
   10,    0,   10,    0,   10,   11,   11,   11,    0,   11,
    0,   11,    0,    0,    0,    0,    0,   17,    0,   13,
   13,   13,    0,   13,   17,   13,   11,    0,   12,    0,
    7,   19,    0,    0,    0,   21,   22,   23,   24,   25,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    2,   10,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    2,    3,
  ]
  yycheck := [                         10,
   40,  259,   94,   10,   -1,   45,   -1,   41,   42,   43,
   10,   45,   42,   47,   -1,   -1,   10,   47,   -1,   10,
   -1,   -1,   -1,   -1,   10,   -1,   -1,   -1,   -1,   40,
   -1,   -1,   10,   -1,   45,   42,   43,   10,   45,   -1,
   47,   -1,   42,   43,   10,   45,   -1,   47,   42,   43,
   41,   45,   43,   47,   45,   41,   42,   43,   10,   45,
   94,   47,   -1,   41,   94,   43,   -1,   45,   41,   42,
   43,   -1,   45,   -1,   47,   41,   42,   43,   -1,   45,
   -1,   47,   -1,   -1,   -1,   -1,   -1,   94,   -1,   41,
   42,   43,   -1,   45,   94,   47,    4,   -1,    6,   -1,
   94,    9,   -1,   -1,   -1,   13,   14,   15,   16,   17,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,  257,  258,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,  257,  258,
  ]
$define YYFINAL 1
$define YYMAXTOKEN 260
  yyname := [
"end-of-file",0,0,0,0,0,0,0,0,0,"'\\n'",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,"'('","')'","'*'","'+'",0,"'-'",0,"'/'",0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,"'^'",0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
"NUM","NAME","ASSIGNMENT","NEG",
  ]
  yyrule := [
"$accept : input",
"input :",
"input : input line",
"line : '\\n'",
"line : exp '\\n'",
"line : NAME ASSIGNMENT exp '\\n'",
"exp : NUM",
"exp : NAME",
"exp : exp '+' exp",
"exp : exp '-' exp",
"exp : exp '*' exp",
"exp : exp '/' exp",
"exp : '-' exp",
"exp : exp '^' exp",
"exp : '(' exp ')'",
  ]

end

#####################################################################
#####################################################################
invocable all    # need to look up semantic actions by name

global yytext    # user variable to return contextual strings
global yyval     # used to return semantic vals from action routines
global yylval    # the 'lval' (result) I got from yylex()
global yydebug   # (boolean) do I want debug output?
global yynerrs   # (integer) number of errors so far
global yyerrflag # (integer) was there an error?
global yychar    # (integer) the current working character
global action    # maps an integer to a semantic action procedure

global yylhs
global yylen
global yydefred
global yydgoto
global yysindex
global yyrindex
global yygindex
global yytable
global yycheck
global yyname
global yyrule

global statestk         # state stack
global valstk           # value stack
################################################################
# procedure: init_stacks : allocate and prepare stacks
################################################################
procedure init_stacks()
  local i
  statestk := []
  valstk := []
  yyval  := 0 
  yylval := 0 
  action := list(1000, action_null)  # remove hard coded 1000 later
  every i := 1 to 1000 do action[i] := proc("action_" || i)
end

#line 37 "calc.y"

 procedure yylex()
   local tok
   static token_char, line
   initial { 
     token_char := ~ ' \t'
     line := ""
   }
   
   if line == "" then line := (read()||"\n") | exit()

   line ? while tab(upto(token_char)) do {
      if yylval := tab(many(&letters)) then tok := NAME
      else if yylval := tab(many(&digits++'.')) then tok := NUM
      else if yylval := =":=" then tok := ASSIGNMENT
      else { yylval := move(1); tok := ord(yylval) }
      line := tab(0)
      return tok
      }   

   tok := ord('\n')
   line := ""
   return tok  # So we look like classic YACC example
 end

 procedure main(args)
   vars := table(0)
   write("IYACC Calculator Demo")
   repeat {   
     write("expression:") 
     yyparse()
   }
end
#line 209 "calc.icn"
$define YYACCEPT return 0
$define YYABORT return 1
################################################################
# procedure: yyparse : parse input and execute indicated items
################################################################
procedure yyparse()
  local yyn        # next next thing to do
  local yym        #
  local yystate    # current parsing state from state table
  local yys        # current token string
  local doaction   # set to 1 if there need to execute action
  local token      # current token

  if /yytable then init() 
  init_stacks() 
  yynerrs   := 0 
  yyerrflag := 0 
  yychar    := -1           # impossible char forces a read
  yystate   := 0            # initial state
  push(statestk, yystate)   # save it

  repeat { # until parsing is done, either correctly, or w/error
    doaction := 1 

    ##### NEXT ACTION (from reduction table)
	yyn := yydefred[yystate+1]

    while yyn = 0 do {

      if yychar < 0 then {   # we want a char?
        yychar := yylex()    # get next token
        ##### ERROR CHECK ####
        if yychar < 0 then { # it it didn't work/error
          yychar := 0        # change it to default string (no -1!)
          if \yydebug = 1 then yylexdebug(yystate, yychar) 
          }
        } # yychar < 0
	  
      yyn := yysindex[yystate+1]  # get amount to shift by (shift index)

      if (yyn ~= 0)           & ((yyn +:= yychar) >= 0) & 
         (yyn <= YYTABLESIZE) & (yycheck[yyn+1] = yychar) then {
		
        ##### NEXT STATE ####
        yystate := yytable[yyn+1] # we are in a new state
        push(statestk, yystate)   # save it
        push(valstk, yylval)      # push our lval as the input for next rule
        yychar := -1              # since we have 'eaten' a token, say we need another
        if yyerrflag > 0 then     # have we recovered an error?
           yyerrflag -:= 1        # give ourselves credit
        doaction := 0             # but don't process yet
        break                     # quit the yyn=0 loop
        }

    yyn := yyrindex[yystate+1]    # reduce

    if (yyn ~= 0)           & ((yyn +:= yychar) >= 0) &
       (yyn <= YYTABLESIZE) & (yycheck[yyn+1] = yychar) then {
      # e reduced!
      yyn      := yytable[yyn+1] 
      doaction := 1  # get ready to execute
      break          # drop down to actions
      }
    else { #ERROR RECOVERY
      if yyerrflag == 0 then {
        (\yyerror | write)("syntax error") 
        yynerrs +:= 1 
      }
      if yyerrflag < 3 then {     # low error count?
        yyerrflag := 3 
        repeat { #do until break
          if *statestk < 1 then {  # check for under & overflow here
            (\yyerror | write)("stack underflow. aborting...")   # note lower case 's'
            return 1 
          }
          yyn := yysindex[statestk[1]] 
          if ((yyn ~= 0) & (yyn +:= YYERRCODE) >= 0 &
                    yyn <= YYTABLESIZE & yycheck[yyn+1] == YYERRCODE) then {
            yystate := yytable[yyn+1] 
            push(statestk, yystate) 
            push(valstk, yylval) 
            doaction := 0 
            break 
          }
          else {
            if *statestk = 0 then { # check for under & overflow here
              write("Stack underflow. aborting...") # capital 'S'
              return 1 
            }
            pop(statestk) 
            pop(valstk) 
            }
          }
        }
      else  # discard this token
        {
        if yychar = 0 then return 1  # yyabort
        if \yydebug = 1 then {
          yys := &null 
          if yychar <= YYMAXTOKEN then yys := yyname[yychar+1] 
          if integer(yys) & yys = 0 then yys := "illegal-symbol" 
          write("state ",  yystate, ", error recovery discards token ",
                yychar, " (", yys, ")") 
          }
        yychar := -1       # read another
        }
      } # end error recovery
      yyn := yydefred[yystate+1] 
    }# yyn = 0 loop

    if doaction = 0 then   # any reason not to proceed?
      next                 # skip action

    yym := yylen[yyn+1]    # get count of terminals on rhs
    yyval := valstk[yym]   # get current semantic value
    if arv := action[yyn]() then return arv # execute the semantic action

    ##### Now let's reduce... ####
    every 1 to yym do pop(statestk)# we just reduced yylen states
    yystate := statestk[1]        # get new state

    every 1 to yym do pop(valstk) # corresponding value drop
    yym := yylhs[yyn+1]           # select next TERMINAL(on lhs)
    if yystate = 0 & yym = 0 then {
                                  # done? 'rest' state and at first TERMINAL
      yystate := YYFINAL          # explicitly say we're done
      push(statestk, YYFINAL)     # and save it
      push(valstk, yyval)         # also save the semantic value of parsing
      if yychar < 0 then {        # we want another character?
        yychar := yylex()         # get next character
        if yychar < 0 then yychar := 0   #clean, if necessary
      }
      if yychar = 0 then break    # Good exit (if lex returns 0  -)
                                  # quit the loop--all DONE
    } # if yystate
    else {                        #else not done yet
      # get next state and push, for next yydefred[]
      yyn := yygindex[yym+1]        # find out where to go
      if (yyn ~= 0)           & ((yyn +:= yystate) >= 0) &
         (yyn <= YYTABLESIZE) & (yycheck[yyn+1] = yystate) then {
        yystate := yytable[yyn+1]   # get new state
        }
      else {
        yystate := yydgoto[yym+1]   # else go to new defred
	     }
      push(statestk, yystate)       # going again, so push state & val...
      push(valstk, yyval)           # for next action
      }
    } # main loop

  return 0 # yyaccept!!
end

### end of procedure parse() ######################################

### start semantic actions ########################################

procedure action_null()
  #write("null action")
end

procedure action_4()
#line 19 "calc.y"
 write(valstk[2]) 
end

procedure action_5()
#line 20 "calc.y"

	      vars[valstk[4]] := valstk[2]
	      write(valstk[2])
	      
end

procedure action_6()
#line 26 "calc.y"
 yyval := valstk[1]         
end

procedure action_7()
#line 27 "calc.y"
 yyval := vars[valstk[1]] 
end

procedure action_8()
#line 28 "calc.y"
 yyval := valstk[3] + valstk[1]    
end

procedure action_9()
#line 29 "calc.y"
 yyval := valstk[3] - valstk[1]    
end

procedure action_10()
#line 30 "calc.y"
 yyval := valstk[3] * valstk[1]    
end

procedure action_11()
#line 31 "calc.y"
 yyval := valstk[3] / valstk[1]    
end

procedure action_12()
#line 32 "calc.y"
 yyval := -valstk[1]        
end

procedure action_13()
#line 33 "calc.y"
 yyval := valstk[3] ^ valstk[1]    
end

procedure action_14()
#line 34 "calc.y"
 yyval := valstk[2]         
end

#line 429 "calc.icn"
