12.1.00 LargeInts


types

   T0: string
   T1: integer
   T2: record
   T3: proc
   T4: coexpr
   T5: tvsubs
   T6: tvtbl
   T7: tvmonitored
   T8: null
   T9: cset
   T10: real
   T11: list
   T12: table
   T13: file
   T14: pattern
   T15: set
   T16: kywdint
   T17: kywdsubj
   T18: kywdpos
   T19: kywdevent
   T20: kywdwin
   T21: kywdstr

$endsect


components

   C0: str_var
   C1: trpd_tbl
   C2: trpd_monitored
   C3: lst_elem
   C4: tbl_key
   C5: tbl_val
   C6: tbl_dflt
   C7: pat_elem
   C8: set_elem

$endsect

functions

Abort	7z 0()	{1,1} _r__ f 
""
0 
0 
lst abstr nil typ T14 
call 0 n _r___ t 0 0 0 
$end

Active	34 0()	{0,1} fr__ f 
"Active() - produce the next active window"
0 
0 
lst abstr nil typ T13 
call 0 s fr___ t 0 0 0 
$end

Alert	35 1(dv)	{1,1} fr_e f 
"Alert(w,volume) - Alert the user"
0 
0 
lst abstr nil typ T13 
call 0 s fr_e_ t 0 0 2 $c dptr argv  $e $c $r0  $e $c int argc  $e $c $r1  $e 
$end

Any	79 1(d)	{1,1} _r_e f 
""
0 
0 
lst abstr nil typ T14 
call 0 s _r_e_ t 0 0 1 $c dptr charset  $e $c &($m0 )  $e 
$end

Arb	7k 0()	{1,1} _r__ f 
""
0 
0 
lst abstr nil typ T14 
call 0 n _r___ t 0 0 0 
$end

Arbno	7l 1(d)	{1,1} _r_e f 
""
0 
0 
lst abstr nil typ T14 
call 0 s _r_e_ t 0 0 1 $c dptr ARBPAT  $e $c &($m0 )  $e 
$end

Attrib	1h 1(dv)	{0,0} ___e f 
"an unavailable function"
0 
0 
runerr1 121 
$end

Bal	7n 0()	{1,1} _r__ f 
""
0 
0 
lst abstr nil typ T14 
call 0 n _r___ t 0 0 0 
$end

Bg	36 1(dv)	{0,1} fr_e f 
"Bg(w,s) - background color"
0 
0 
lst abstr nil typ T0 
call 0 s fr_e_ t 0 0 2 $c dptr argv  $e $c $r0  $e $c int argc  $e $c $r1  $e 
$end

Break	7a 1(d)	{1,1} _r_e f 
""
0 
0 
lst abstr nil typ T14 
call 0 s _r_e_ t 0 0 1 $c dptr charset  $e $c &($m0 )  $e 
$end

Breakx	7e 1(d)	{1,1} _r_e f 
""
0 
0 
lst abstr nil typ T14 
call 0 s _r_e_ t 0 0 1 $c dptr char_set  $e $c &($m0 )  $e 
$end

Clip	37 1(dv)	{1,1} fr_e f 
"Clip(w, x, y, w, h) - set context clip rectangle"
0 
0 
lst abstr nil typ T13 
call 0 s fr_e_ t 0 0 2 $c dptr argv  $e $c $r0  $e $c int argc  $e $c $r1  $e 
$end

Clone	38 1(dv)	{1,1} fr_e t 
"Clone(w, attribs...) - create a new context bound to w's canvas"
0 
0 
lst abstr nil ++ typ T13 typ T2 
call 0 s fr_e_ t 0 0 2 $c dptr argv  $e $c $m0  $e $c int argc  $e $c $r1  $e 
$end

Color	39 1(dv)	{0,1} fr_e f 
"Color(argv[]) - return or set color map entries"
0 
0 
lst abstr nil ++ typ T13 typ T0 
call 0 s fr_e_ t 0 0 2 $c dptr argv  $e $c $r0  $e $c int argc  $e $c $r1  $e 
$end

ColorValue	3a 1(dv)	{0,1} fr_e f 
"ColorValue(w,s) - produce RGB components from string color name"
0 
0 
lst abstr nil typ T0 
call 0 s fr_e_ t 0 0 2 $c int argc  $e $c $r1  $e $c dptr argv  $e $c $r0  $e 
$end

CopyArea	3b 1(dv)	{0,1} fr_e f 
"CopyArea(w,w2,x,y,width,height,x2,y2) - copy area"
0 
0 
lst abstr nil typ T13 
call 0 s fr_e_ t 0 0 2 $c dptr argv  $e $c $r0  $e $c int argc  $e $c $r1  $e 
$end

Couple	3c 2(d,d)	{0,1} fr_e t 
"Couple(w,w2) - couple canvas to context"
0 
0 
lst abstr nil typ T13 
call 0 s fr_e_ t 0 0 2 $c dptr w2  $e $c &($r1 )  $e $c dptr w  $e $c &($r0 )  $e 
$end

DrawArc	3d 1(dv)	{1,1} fr_e f 
"DrawArc(argv[]){1} - draw arc"
0 
0 
lst abstr nil typ T13 
call 0 s fr_e_ t 0 0 2 $c dptr argv  $e $c $r0  $e $c int argc  $e $c $r1  $e 
$end

DrawCircle	3e 1(dv)	{1,1} fr_e f 
"DrawCircle(argv[]){1} - draw circle"
0 
0 
lst abstr nil typ T13 
call 0 s fr_e_ t 0 0 2 $c dptr argv  $e $c $r0  $e $c int argc  $e $c $r1  $e 
$end

DrawCube	4s 1(dv)	{1,1} fr_e f 
"DrawCube(argv[]){1} - draw a cube"
0 
0 
lst abstr nil typ T2 
call 0 s fr_e_ t 0 0 2 $c dptr argv  $e $c $r0  $e $c int argc  $e $c $r1  $e 
$end

DrawCurve	3f 1(dv)	{1,1} fr_e f 
"DrawCurve(argv[]){1} - draw curve"
0 
0 
lst abstr nil typ T13 
call 0 s fr_e_ t 0 0 2 $c dptr argv  $e $c $r0  $e $c int argc  $e $c $r1  $e 
$end

DrawCylinder	4u 1(dv)	{1,1} fr_e f 
"DrawCylinder(argv[]){1} - draw a cylinder"
0 
0 
lst abstr nil typ T2 
call 0 s fr_e_ t 0 0 2 $c dptr argv  $e $c $r0  $e $c int argc  $e $c $r1  $e 
$end

DrawDisk	4v 1(dv)	{1,1} fr_e f 
"DrawDisk(argv[]){1} - draw a disk"
0 
0 
lst abstr nil typ T2 
call 0 s fr_e_ t 0 0 2 $c dptr argv  $e $c $r0  $e $c int argc  $e $c $r1  $e 
$end

DrawImage	3g 1(dv)	{0,1} fr_e f 
"DrawImage(w,x,y,s) - draw bitmapped figure"
0 
0 
lst abstr nil ++ typ T8 typ T1 
call 0 s fr_e_ t 0 0 2 $c dptr argv  $e $c $r0  $e $c int argc  $e $c $r1  $e 
$end

DrawLine	3h 1(dv)	{1,1} fr_e f 
"DrawLine(argv[]){1} - draw line"
0 
0 
lst abstr nil typ T13 
call 0 s fr_e_ t 0 0 2 $c dptr argv  $e $c $m0  $e $c int argc  $e $c $r1  $e 
$end

DrawPoint	3i 1(dv)	{1,1} fr_e f 
"DrawPoint(argv[]){1} - draw point"
0 
0 
lst abstr nil typ T13 
call 0 s fr_e_ t 0 0 2 $c dptr argv  $e $c $m0  $e $c int argc  $e $c $r1  $e 
$end

DrawPolygon	3j 1(dv)	{1,1} fr_e f 
"DrawPolygon(argv[]){1} - draw polygon"
0 
0 
lst abstr nil typ T13 
call 0 s fr_e_ t 0 0 2 $c dptr argv  $e $c $m0  $e $c int argc  $e $c $r1  $e 
$end

DrawRectangle	3k 1(dv)	{1,1} fr_e f 
"DrawRectangle(argv[]){1} - draw rectangle"
0 
0 
lst abstr nil typ T13 
call 0 s fr_e_ t 0 0 2 $c dptr argv  $e $c $r0  $e $c int argc  $e $c $r1  $e 
$end

DrawSegment	3l 1(dv)	{1,1} fr_e f 
"DrawSegment(argv[]){1} - draw line segment"
0 
0 
lst abstr nil typ T13 
call 0 s fr_e_ t 0 0 2 $c dptr argv  $e $c $m0  $e $c int argc  $e $c $r1  $e 
$end

DrawSphere	4t 1(dv)	{1,1} fr_e f 
"DrawSphere(argv[]){1} - draw a sphere"
0 
0 
lst abstr nil typ T2 
call 0 s fr_e_ t 0 0 2 $c dptr argv  $e $c $r0  $e $c int argc  $e $c $r1  $e 
$end

DrawString	3m 1(dv)	{1,1} fr_e f 
"DrawString(argv[]){1} - draw text"
0 
0 
lst abstr nil typ T13 
call 0 s fr_e_ t 0 0 2 $c dptr argv  $e $c $m0  $e $c int argc  $e $c $r1  $e 
$end

DrawTorus	4r 1(dv)	{1,1} fr_e f 
"DrawTorus(argv[]) - draw a torus"
0 
0 
lst abstr nil typ T2 
call 0 s fr_e_ t 0 0 2 $c dptr argv  $e $c $r0  $e $c int argc  $e $c $r1  $e 
$end

EraseArea	3n 1(dv)	{1,1} fr_e f 
"EraseArea(w,x,y,width,height) - clear an area of the window"
0 
0 
lst abstr nil typ T13 
call 0 s fr_e_ t 0 0 2 $c dptr argv  $e $c $r0  $e $c int argc  $e $c $r1  $e 
$end

Event	3o 1(dv)	{1,1} fr_e f 
"Event(w) - return an event from a window"
0 
0 
lst abstr nil ++ typ T0 typ T1 
call 0 s fr_e_ t 0 0 2 $c dptr argv  $e $c $r0  $e $c int argc  $e $c $r1  $e 
$end

Eye	4w 1(dv)	{1,1} fr_e t 
"Eye(argv[]){1} - get/set eye attributes"
0 
0 
lst abstr nil typ T2 
call 0 s fr_e_ t 0 0 2 $c dptr argv  $e $c $r0  $e $c int argc  $e $c $r1  $e 
$end

Fail	81 0()	{1,1} _r__ f 
""
0 
0 
lst abstr nil typ T14 
call 0 n _r___ t 0 0 0 
$end

Fence	7x 1(d)	{1,1} _r_e f 
""
0 
0 
lst abstr nil typ T14 
if2 is T8 0 
call 0 n _r___ t 0 0 0 
call 1 s _r_e_ t 0 0 1 $c dptr P  $e $c &($m0 )  $e 
$end

Fg	3p 1(dv)	{0,1} fr_e f 
"Fg(w,s) - foreground color"
0 
0 
lst abstr nil typ T0 
call 0 s fr_e_ t 0 0 2 $c dptr argv  $e $c $r0  $e $c int argc  $e $c $r1  $e 
$end

FillArc	3q 1(dv)	{1,1} fr_e f 
"FillArc(argv[]){1} - fill arc"
0 
0 
lst abstr nil typ T13 
call 0 s fr_e_ t 0 0 2 $c dptr argv  $e $c $r0  $e $c int argc  $e $c $r1  $e 
$end

FillCircle	3r 1(dv)	{1,1} fr_e f 
"FillCircle(argv[]){1} - draw filled circle"
0 
0 
lst abstr nil typ T13 
call 0 s fr_e_ t 0 0 2 $c dptr argv  $e $c $r0  $e $c int argc  $e $c $r1  $e 
$end

FillPolygon	3s 1(dv)	{1,1} fr_e f 
"FillPolygon(argv[]){1} - fill polygon"
0 
0 
lst abstr nil typ T13 
call 0 s fr_e_ t 0 0 2 $c dptr argv  $e $c $m0  $e $c int argc  $e $c $r1  $e 
$end

FillRectangle	3t 1(dv)	{1,1} fr_e f 
"FillRectangle(argv[]){1} - draw filled rectangle"
0 
0 
lst abstr nil typ T13 
call 0 s fr_e_ t 0 0 2 $c dptr argv  $e $c $r0  $e $c int argc  $e $c $r1  $e 
$end

Font	3u 1(dv)	{0,1} fr_e f 
"Font(w,s) - get/set font"
0 
0 
lst abstr nil typ T0 
call 0 s fr_e_ t 0 0 2 $c dptr argv  $e $c $r0  $e $c int argc  $e $c $r1  $e 
$end

FreeColor	3v 1(dv)	{1,1} fr_e f 
"FreeColor(argv[]) - free colors"
0 
0 
lst abstr nil typ T13 
call 0 s fr_e_ t 0 0 2 $c dptr argv  $e $c $r0  $e $c int argc  $e $c $r1  $e 
$end

GotoRC	3w 1(dv)	{1,1} fr_e f 
"GotoRC(w,r,c) - move cursor to a particular text row and column"
0 
0 
lst abstr nil typ T13 
call 0 s fr_e_ t 0 0 2 $c dptr argv  $e $c $r0  $e $c int argc  $e $c $r1  $e 
$end

GotoXY	3x 1(dv)	{1,1} fr_e f 
"GotoXY(w,x,y) - move cursor to a particular pixel location"
0 
0 
lst abstr nil typ T13 
call 0 s fr_e_ t 0 0 2 $c dptr argv  $e $c $r0  $e $c int argc  $e $c $r1  $e 
$end

IdentityMatrix	55 1(dv)	{1,1} fr_e f 
"IdentityMatrix(argv[]){1} - change the top matrix to the identity"
0 
0 
lst abstr nil typ T2 
call 0 s fr_e_ t 0 0 2 $c dptr argv  $e $c $r0  $e $c int argc  $e $c $r1  $e 
$end

Len	7f 1(d)	{1,1} _r_e f 
""
0 
0 
lst abstr nil typ T14 
if2 is T14 0 
call 0 s _r_e_ t 0 0 1 $c dptr count  $e $c &($r0 )  $e 
if2 cnv1 T1 0 
call 1 n _r___ t 0 0 1 $c dptr count  $e $c &($r0 )  $e 
runerr2 102 0 
$end

Lower	3y 1(dv)	{1,1} fr_e f 
"Lower(w) - lower w to the bottom of the window stack"
0 
0 
lst abstr nil typ T13 
call 0 s fr_e_ t 0 0 2 $c dptr argv  $e $c $r0  $e $c int argc  $e $c $r1  $e 
$end

MatrixMode	56 1(dv)	{1,1} fr_e f 
"MatrixMode(argv[]){1} - use the matrix stack specified by s"
0 
0 
lst abstr nil typ T2 
call 0 s fr_e_ t 0 0 2 $c dptr argv  $e $c $r0  $e $c int argc  $e $c $r1  $e 
$end

MultMatrix	5a 1(dv)	{1,1} fr_e f 
"MultMatrix(argv[]){1} - multiply transformation matrix by the list L "
0 
0 
lst abstr nil typ T11 
call 0 s fr_e_ t 0 0 2 $c dptr argv  $e $c $m0  $e $c int argc  $e $c $r1  $e 
$end

NewColor	3z 1(dv)	{0,1} fr_e f 
"NewColor(w,s) - allocate an entry in the color map"
0 
0 
lst abstr nil typ T1 
call 0 s fr_e_ t 0 0 2 $c dptr argv  $e $c $r0  $e $c int argc  $e $c $r1  $e 
$end

Normals	59 1(dv)	{1,1} fr_e f 
"Normal(argv[]){1} - set texture coordinate to those defined by the string s or the list L "
0 
0 
lst abstr nil typ T11 
call 0 s fr_e_ t 0 0 2 $c dptr argv  $e $c $m0  $e $c int argc  $e $c $r1  $e 
$end

NotAny	7b 1(d)	{1,1} _r_e f 
""
0 
0 
lst abstr nil typ T14 
call 0 s _r_e_ t 0 0 1 $c dptr char_set  $e $c &($m0 )  $e 
$end

Nspan	7d 1(d)	{1,1} _r_e f 
""
0 
0 
lst abstr nil typ T14 
call 0 s _r_e_ t 0 0 1 $c dptr char_set  $e $c &($m0 )  $e 
$end

PaletteChars	40 1(dv)	{0,1} fr_e f 
"PaletteChars(w,p) - return the characters forming keys to palette p"
0 
0 
lst abstr nil typ T0 
call 0 s fr_e_ t 0 0 2 $c int argc  $e $c $r1  $e $c dptr argv  $e $c $m0  $e 
$end

PaletteColor	41 1(dv)	{0,1} fr_e f 
"PaletteColor(w,p,s) - return color of key s in palette p"
0 
0 
lst abstr nil typ T0 
call 0 s fr_e_ t 0 0 2 $c int argc  $e $c $r1  $e $c dptr argv  $e $c $m0  $e 
$end

PaletteKey	42 1(dv)	{0,1} fr_e f 
"PaletteKey(w,p,s) - return key of closest color to s in palette p"
0 
0 
lst abstr nil typ T0 
call 0 s fr_e_ t 0 0 2 $c int argc  $e $c $r1  $e $c dptr argv  $e $c $m0  $e 
$end

Pattern	43 1(dv)	{1,1} fr_e f 
"Pattern(w,s) - sets the context fill pattern by string name"
0 
0 
lst abstr nil typ T13 
call 0 s fr_e_ t 0 0 2 $c dptr argv  $e $c $m0  $e $c int argc  $e $c $r1  $e 
$end

Pending	44 1(dv)	{0,1} fr_e f 
"Pending(w,x[]) - produce a list of events pending on window"
0 
0 
lst abstr nil typ T11 
call 0 s fr_e_ t 0 0 2 $c dptr argv  $e $c $m0  $e $c int argc  $e $c $r1  $e 
$end

Pixel	45 1(dv)	{3,3} f_se f 
"Pixel(w,x,y,width,height) - produce the contents of some pixels"
0 
0 
lst abstr nil ++ typ T1 typ T0 
call 0 s f_se_ t 0 0 2 $c dptr argv  $e $c $r0  $e $c int argc  $e $c $r1  $e 
$end

PlayAudio	75 1(d)	{} ___e f 
"an unavailable function"
0 
0 
runerr1 121 
$end

PopMatrix	50 1(dv)	{1,1} fr_e f 
"PopMatrix(argv[]){1} - pop the matrix stack"
0 
0 
lst abstr nil typ T2 
call 0 s fr_e_ t 0 0 2 $c dptr argv  $e $c $r0  $e $c int argc  $e $c $r1  $e 
$end

Pos	7g 1(d)	{1,1} _r_e f 
""
0 
0 
lst abstr nil typ T14 
if2 is T14 0 
call 0 s _r_e_ t 0 0 1 $c dptr position  $e $c &($r0 )  $e 
if2 cnv1 T1 0 
call 1 n _r___ t 0 0 1 $c dptr position  $e $c &($r0 )  $e 
runerr2 102 0 
$end

PushMatrix	51 1(dv)	{1,1} fr_e f 
"PushMatrix(argv[]){1} - push a copy of the top matrix onto the matrix stack"
0 
0 
lst abstr nil typ T2 
call 0 s fr_e_ t 0 0 2 $c dptr argv  $e $c $r0  $e $c int argc  $e $c $r1  $e 
$end

PushRotate	53 1(dv)	{2,2} frse f 
"PushRotate(argv[]){1} - push a copy of the top matrix onto the matrix stack and apply rotations"
0 
0 
lst abstr nil typ T2 
call 0 s frse_ t 0 0 2 $c dptr argv  $e $c $r0  $e $c int argc  $e $c $r1  $e 
$end

PushScale	54 1(dv)	{2,2} frse f 
"PushScale(argv[]){1} - push a copy of the top matrix onto the matrix stack and apply scales"
0 
0 
lst abstr nil typ T2 
call 0 s frse_ t 0 0 2 $c dptr argv  $e $c $r0  $e $c int argc  $e $c $r1  $e 
$end

PushTranslate	52 1(dv)	{2,2} frse f 
"PushTranslate(argv[]){1} - push a copy of the top matrix onto the matrix stack and apply translations"
0 
0 
lst abstr nil typ T2 
call 0 s frse_ t 0 0 2 $c dptr argv  $e $c $r0  $e $c int argc  $e $c $r1  $e 
$end

QueryPointer	46 1(d)	{0,2} f_se f 
"QueryPointer(w) - produce mouse position"
0 
1 xp $c XPoint xp;  $e 
lst abstr nil typ T1 
call 0 s f_se_ t 0 0 2 $c XPoint (*xp)  $e $c &($m1 )  $e $c dptr w  $e $c &($r0 )  $e 
$end

Raise	47 1(dv)	{1,1} fr_e f 
"Raise(w) - raise w to the top of the window stack"
0 
0 
lst abstr nil typ T13 
call 0 s fr_e_ t 0 0 2 $c dptr argv  $e $c $r0  $e $c int argc  $e $c $r1  $e 
$end

ReadImage	48 1(dv)	{0,1} fr_e f 
"ReadImage(w, s, x, y, p) - load image file"
0 
0 
lst abstr nil typ T1 
call 0 s fr_e_ t 0 0 2 $c dptr argv  $e $c $m0  $e $c int argc  $e $c $r1  $e 
$end

Refresh	5b 1(dv)	{1,1} fr_e f 
"Refresh(argv[]){1} - redraws the window"
0 
0 
lst abstr nil typ T13 
call 0 s fr_e_ t 0 0 2 $c dptr argv  $e $c $r0  $e $c int argc  $e $c $r1  $e 
$end

Rem	80 0()	{1,1} _r__ f 
""
0 
0 
lst abstr nil typ T14 
call 0 n _r___ t 0 0 0 
$end

Rotate	4x 1(dv)	{1,1} fr_e f 
"Rotate(argv[]){1} - rotates objects"
0 
0 
lst abstr nil typ T2 
call 0 s fr_e_ t 0 0 2 $c dptr argv  $e $c $r0  $e $c int argc  $e $c $r1  $e 
$end

Rpos	7h 1(d)	{1,1} _r_e f 
""
0 
0 
lst abstr nil typ T14 
if2 is T14 0 
call 0 s _r_e_ t 0 0 1 $c dptr position  $e $c &($r0 )  $e 
if2 cnv1 T1 0 
call 1 n _r___ t 0 0 1 $c dptr position  $e $c &($r0 )  $e 
runerr2 102 0 
$end

Rtab	7j 1(d)	{1,1} _r_e f 
""
0 
0 
lst abstr nil typ T14 
if2 is T14 0 
call 0 s _r_e_ t 0 0 1 $c dptr count  $e $c &($r0 )  $e 
if2 cnv1 T1 0 
call 1 n _r___ t 0 0 1 $c dptr count  $e $c &($r0 )  $e 
runerr2 102 0 
$end

Scale	4z 1(dv)	{1,1} fr_e f 
"Scale(argv[]){1} - scales objects"
0 
0 
lst abstr nil typ T2 
call 0 s fr_e_ t 0 0 2 $c dptr argv  $e $c $r0  $e $c int argc  $e $c $r1  $e 
$end

Span	7c 1(d)	{1,1} _r_e f 
""
0 
0 
lst abstr nil typ T14 
call 0 s _r_e_ t 0 0 1 $c dptr char_set  $e $c &($m0 )  $e 
$end

StopAudio	76 1(d)	{} ___e f 
"an unavailable function"
0 
0 
runerr1 121 
$end

Succeed	7m 0()	{1,1} _r__ f 
""
0 
0 
lst abstr nil typ T14 
call 0 n _r___ t 0 0 0 
$end

Tab	7i 1(d)	{1,1} _r_e f 
""
0 
0 
lst abstr nil typ T14 
if2 is T14 0 
call 0 s _r_e_ t 0 0 1 $c dptr count  $e $c &($r0 )  $e 
if2 cnv1 T1 0 
call 1 n _r___ t 0 0 1 $c dptr count  $e $c &($r0 )  $e 
runerr2 102 0 
$end

Texcoord	58 1(dv)	{1,1} fr_e f 
"Texcoord(argv[]){1} - set texture coordinate to those defined by the string s or the list L "
0 
0 
lst abstr nil typ T11 
call 0 s fr_e_ t 0 0 2 $c dptr argv  $e $c $m0  $e $c int argc  $e $c $r1  $e 
$end

TextWidth	4a 1(dv)	{1,1} fr_e f 
"TextWidth(w,s) - compute text pixel width"
0 
0 
lst abstr nil typ T1 
call 0 s fr_e_ t 0 0 2 $c dptr argv  $e $c $m0  $e $c int argc  $e $c $r1  $e 
$end

Texture	57 1(dv)	{1,1} fr_e f 
"Texture([w], x) - apply the texture defined by the string or window x as a texture "
0 
0 
lst abstr nil typ T2 
call 0 s fr_e_ t 0 0 2 $c dptr argv  $e $c $r0  $e $c int argc  $e $c $r1  $e 
$end

Translate	4y 1(dv)	{1,1} fr_e f 
"Translate(argv[]){1} - translates objects"
0 
0 
lst abstr nil typ T2 
call 0 s fr_e_ t 0 0 2 $c dptr argv  $e $c $r0  $e $c int argc  $e $c $r1  $e 
$end

Uncouple	4b 1(d)	{1,1} _r_e f 
"Uncouple(w) - uncouple window"
0 
0 
lst abstr nil typ T13 
call 0 s _r_e_ t 0 0 1 $c dptr w  $e $c &($r0 )  $e 
$end

VAttrib	77 1(dv)	{0,0} ___e f 
"an unavailable function"
0 
0 
runerr1 121 
$end

WAttrib	4c 1(dv)	{0,*} frse f 
"WAttrib(argv[]) - read/write window attributes"
0 
0 
lst abstr nil ++ ++ typ T13 typ T0 typ T1 
call 0 s frse_ t 0 0 2 $c dptr argv  $e $c $m0  $e $c int argc  $e $c $r1  $e 
$end

WDefault	4d 1(dv)	{0,1} fr_e f 
"WDefault(w,program,option) - get a default value from the environment"
0 
0 
lst abstr nil typ T0 
call 0 s fr_e_ t 0 0 2 $c dptr argv  $e $c $r0  $e $c int argc  $e $c $r1  $e 
$end

WFlush	4e 1(dv)	{1,1} fr_e f 
"WFlush(w) - flush all output to window w"
0 
0 
lst abstr nil typ T13 
call 0 s fr_e_ t 0 0 2 $c dptr argv  $e $c $r0  $e $c int argc  $e $c $r1  $e 
$end

WSection	5d 1(dv)	{1,1} fr_e f 
"WSection(argv[]){1} - mark section"
0 
0 
lst abstr nil ++ typ T13 typ T1 
call 0 s fr_e_ t 0 0 2 $c dptr argv  $e $c $m0  $e $c int argc  $e $c $r1  $e 
$end

WSync	49 1(d)	{1,1} _r_e f 
"WSync(w) - synchronize with server"
0 
0 
lst abstr nil ++ typ T13 typ T8 
call 0 s _r_e_ t 0 0 1 $c dptr w  $e $c &($r0 )  $e 
$end

WinAssociate	4g 1(d)	{} ___e f 
"an unavailable function"
0 
0 
runerr1 121 
$end

WinButton	4i 1(dv)	{0,0} ___e f 
"an unavailable function"
0 
0 
runerr1 121 
$end

WinColorDialog	4m 1(dv)	{0,0} ___e f 
"an unavailable function"
0 
0 
runerr1 121 
$end

WinEditRegion	4l 1(dv)	{0,0} ___e f 
"an unavailable function"
0 
0 
runerr1 121 
$end

WinFontDialog	4n 1(dv)	{0,0} ___e f 
"an unavailable function"
0 
0 
runerr1 121 
$end

WinMenuBar	4k 1(dv)	{0,0} ___e f 
"an unavailable function"
0 
0 
runerr1 121 
$end

WinOpenDialog	4o 1(dv)	{0,0} ___e f 
"an unavailable function"
0 
0 
runerr1 121 
$end

WinPlayMedia	4h 1(dv)	{0,0} ___e f 
"an unavailable function"
0 
0 
runerr1 121 
$end

WinSaveDialog	4q 1(dv)	{0,0} ___e f 
"an unavailable function"
0 
0 
runerr1 121 
$end

WinScrollBar	4j 1(dv)	{0,0} ___e f 
"an unavailable function"
0 
0 
runerr1 121 
$end

WinSelectDialog	4p 1(dv)	{0,0} ___e f 
"an unavailable function"
0 
0 
runerr1 121 
$end

WindowContents	5c 1(dv)	{1,1} fr_e f 
"WindowContents(argv[]){1} - returns an Icon list of lists, which contains all objects drawn on window"
0 
0 
lst abstr nil typ T11 
call 0 s fr_e_ t 0 0 2 $c dptr argv  $e $c $r0  $e $c int argc  $e $c $r1  $e 
$end

WriteImage	4f 1(dv)	{0,1} fr_e f 
"WriteImage(w,filename,x,y,width,height) - write an image to a file"
0 
0 
lst abstr nil typ T13 
call 0 s fr_e_ t 0 0 2 $c dptr argv  $e $c $r0  $e $c int argc  $e $c $r1  $e 
$end

abs	00 1(d)	{1,1} _r_e t 
"abs(N) - produces the absolute value of N."
0 
0 
if2 cnv1 eci 0 
lst abstr nil typ T1 
block _ 0 $c ${ C_integer i; 
int over_flow = 0;
$cgoto $c $r0 >= 0  $e 0 i = neg($r0 , &over_flow);
$cgoto $c !(over_flow)  $e 1 ${ struct descrip tmp;
MakeInt($r0 , &tmp);
$cgoto $c !(bigneg(&tmp, &$mr ) == RunError)  $e 2 err_msg(0, NULL);
$efail $lbl 2 $ret rn 0 $} $lbl 1 $goto 3 $lbl 0 i = $r0 ;
$lbl 3 $ret ci 1 $c i  $e $}  $e 
if2 cnv1 ei 0 
lst abstr nil typ T1 
block _ 0 $c $cgoto $c BlkD($r0 , Lrgint)->sign == 0  $e 4 $cgoto $c !(bigneg(&$m0 , &$mr ) == RunError)  $e 5 err_msg(0, NULL);
$efail $lbl 5 $goto 6 $lbl 4 $mr = $r0 ;
$lbl 6 $ret rn 0  $e 
if2 cnv1 cd 0 
lst abstr nil typ T10 
block _ 0 $c $ret cd 1 $c Abs($r0 )  $e  $e 
runerr2 102 0 
$end

acos	0b 1(d)	{1,1} _r_e f 
"acos(r), x in radians."
0 
0 
lst lst if1 ! cnv1 cd 0 
runerr2 102 0 
abstr nil typ T10 
block _ 0 $c ${ double y;
$cgoto $c !($r0 < -1.0 || $r0 > 1.0)  $e 0 drunerr(205, $r0 );
$efail $lbl 0 errno = 0;
y = acos($r0 );
$cgoto $c !(errno == EDOM)  $e 1 err_msg(205, NULL);
$efail $lbl 1 $ret cd 1 $c y  $e $}  $e 
$end

any	1u 4(d,d,d,d)	{0,1} fr_e f 
"any(c,s,i1,i2) - produces min(i1,i2)+1 if s[min(i1,i2)] is contained in c and i1 ~= i2, but fails otherwise."
0 
2 cnv_i $c C_integer cnv_i;  $e cnv_j $c C_integer cnv_j;  $e 
lst lst lst lst lst abstr nil typ T1 
if2 is T8 1 
lst block t 0 $c CURTSTATE();
$m1 = k_subject;  $e 
if1 is T8 2 
block t 0 $c CURTSTATE();
$m4 = k_pos;  $e 
lst if1 ! cnv1 T0 1 
runerr2 103 1 
if1 is T8 2 
block t 0 $c $m4 = 1;  $e 
if1 ! is T8 2 
if2 cnv2 ci 2 $c $m4  $e 
block t 0 $c $cgoto $c !(($m4 = cvpos($r4 , StrLen($r1 ))) == CvtFail)  $e 0 $fail $lbl 0  $e 
runerr2 101 2 
if2 is T8 3 
block t 0 $c $m5 = StrLen($r1 ) + 1;  $e 
if2 cnv2 ci 3 $c $m5  $e 
block t 0 $c $cgoto $c !(($m5 = cvpos($r5 , StrLen($r1 ))) == CvtFail)  $e 1 $fail $lbl 1 $cgoto $c !($r4 > $r5 )  $e 2 ${ register C_integer tmp;
tmp = $r4 ;
$m4 = $r5 ;
$m5 = tmp;
$} $lbl 2  $e 
runerr2 101 3 
if1 ! cnv1 tc 0 
runerr2 104 0 
call 0 s fr___ t 0 0 4 $c dptr c  $e $c &($r0 )  $e $c dptr s  $e $c &($r1 )  $e $c C_integer cnv_j  $e $c $r5  $e $c C_integer cnv_i  $e $c $r4  $e 
$end

args	0m 2(d,d)	{0,1} fr_e f 
"args(x,i) - produce number of arguments for procedure x."
0 
0 
if2 is T3 0 
lst abstr nil typ T1 
block _ 0 $c $ret ci 1 $c BlkD($r0 , Proc)->nparam  $e  $e 
if2 ! is T4 0 
runerr2 106 0 
if2 is T8 1 
lst abstr nil typ T1 
block _ 0 $c $fail  $e 
if2 ! cnv1 T1 1 
runerr2 103 1 
lst abstr nil typ a 
block _ 0 $c $fail  $e 
$end

array	2j 1(dv)	{1,1} _r_e f 
""
0 
0 
lst abstr nil new T11 1 ++ typ T1 typ T10 
call 0 s _r_e_ t 0 0 2 $c dptr x  $e $c $m0  $e $c int n  $e $c $r1  $e 
$end

asin	0c 1(d)	{1,1} _r_e f 
"asin(r), x in radians."
0 
0 
lst lst if1 ! cnv1 cd 0 
runerr2 102 0 
abstr nil typ T10 
block _ 0 $c ${ double y;
$cgoto $c !($r0 < -1.0 || $r0 > 1.0)  $e 0 drunerr(205, $r0 );
$efail $lbl 0 errno = 0;
y = asin($r0 );
$cgoto $c !(errno == EDOM)  $e 1 err_msg(205, NULL);
$efail $lbl 1 $ret cd 1 $c y  $e $}  $e 
$end

atan	0i 2(d,d)	{1,1} _r_e f 
"atan(r1,r2) -- r1, r2  in radians; if r2 is present, produces atan2(r1,r2)."
0 
0 
lst lst lst lst if1 ! cnv1 cd 0 
runerr2 102 0 
abstr nil typ T10 
if1 is T8 1 
block _ 0 $c $ret cd 1 $c atan($r0 )  $e  $e 
if1 ! cnv1 cd 1 
runerr2 102 1 
block _ 0 $c $ret cd 1 $c atan2($r0 , $r1 )  $e  $e 
$end

atanh	0d 1(d)	{1,1} _r_e f 
"atanh(r), x in radians."
0 
0 
lst lst if1 ! cnv1 cd 0 
runerr2 102 0 
abstr nil typ T10 
block _ 0 $c ${ double y;
$cgoto $c !($r0 < -1.0 || $r0 > 1.0)  $e 0 drunerr(205, $r0 );
$efail $lbl 0 errno = 0;
y = atanh($r0 );
$cgoto $c !(errno == EDOM)  $e 1 err_msg(205, NULL);
$efail $lbl 1 $ret cd 1 $c y  $e $}  $e 
$end

bal	1v 6(d,d,d,d,d,d)	{0,*} f_se f 
"bal(c1,c2,c3,s,i1,i2) - generates the sequence of integer positions in s up to a character of c1 in s[i1:i2] that is balanced with respect to characters in c2 and c3, but fails if there is no such position."
0 
2 cnv_i $c C_integer cnv_i;  $e cnv_j $c C_integer cnv_j;  $e 
lst lst lst lst lst lst lst abstr nil typ T1 
if2 is T8 3 
lst block t 0 $c CURTSTATE();
$m3 = k_subject;  $e 
if1 is T8 4 
block t 0 $c CURTSTATE();
$m6 = k_pos;  $e 
lst if1 ! cnv1 T0 3 
runerr2 103 3 
if1 is T8 4 
block t 0 $c $m6 = 1;  $e 
if1 ! is T8 4 
if2 cnv2 ci 4 $c $m6  $e 
block t 0 $c $cgoto $c !(($m6 = cvpos($r6 , StrLen($r3 ))) == CvtFail)  $e 0 $fail $lbl 0  $e 
runerr2 101 4 
if2 is T8 5 
block t 0 $c $m7 = StrLen($r3 ) + 1;  $e 
if2 cnv2 ci 5 $c $m7  $e 
block t 0 $c $cgoto $c !(($m7 = cvpos($r7 , StrLen($r3 ))) == CvtFail)  $e 1 $fail $lbl 1 $cgoto $c !($r6 > $r7 )  $e 2 ${ register C_integer tmp;
tmp = $r6 ;
$m6 = $r7 ;
$m7 = tmp;
$} $lbl 2  $e 
runerr2 101 5 
if1 ! def1 tc 0 $c k_cset  $e 
runerr2 104 0 
if1 ! def1 tc 1 $c lparcs  $e 
runerr2 104 1 
if1 ! def1 tc 2 $c rparcs  $e 
runerr2 104 2 
call 0 s f_s__ t 0 0 6 $c dptr c3  $e $c &($r2 )  $e $c dptr c2  $e $c &($r1 )  $e $c dptr c1  $e $c &($r0 )  $e $c dptr s  $e $c &($r3 )  $e $c C_integer cnv_j  $e $c $r7  $e $c C_integer cnv_i  $e $c $m6  $e 
$end

center	1l 3(d,d,d)	{1,1} _r_e f 
"center(s1,i,s2) - pad s1 on left and right with s2 to length i."
0 
0 
lst lst lst lst if1 ! cnv1 T0 0 
runerr2 103 0 
if1 ! def1 ci 1 $c 1  $e 
runerr2 101 1 
if1 ! def1 ts 2 $c blank  $e 
runerr2 103 2 
abstr nil typ T0 
call 0 s _r_e_ t 0 0 3 $c dptr s1  $e $c &($r0 )  $e $c dptr s2  $e $c &($m2 )  $e $c C_integer n  $e $c $r1  $e 
$end

char	0n 1(d)	{1,1} _r_e f 
"char(i) - produce a string consisting of character i."
0 
0 
lst lst if1 ! cnv1 ci 0 
runerr2 101 0 
abstr nil typ T0 
call 0 s _r_e_ t 0 0 1 $c C_integer i  $e $c $r0  $e 
$end

chdir	31 1(d)	{0,1} fr_e t 
"chdir(s) - change working directory to s."
0 
0 
lst lst if1 ! cnv1 T0 0 
if1 ! is T8 0 
runerr2 103 0 
abstr nil typ T0 
call 0 s fr_e_ t 0 0 1 $c dptr s  $e $c &($r0 )  $e 
$end

chmod	5v 2(d,d)	{0,1} fr_e f 
"chmod() - change the permission on a file."
0 
0 
lst if1 ! is T0 1 
if1 ! is T1 1 
runerr2 170 1 
tcase2 0 2 
1 T13 lst abstr nil typ T8 
call 0 s fr_e_ t 0 0 2 $c dptr m  $e $c &($r1 )  $e $c dptr s  $e $c &($r0 )  $e 
1 T0 lst abstr nil typ T8 
call 1 s fr_e_ t 0 0 2 $c dptr m  $e $c &($r1 )  $e $c dptr s  $e $c &($r0 )  $e 
runerr2 109 0 
$end

chown	5u 3(d,d,d)	{0,1} fr_e f 
"chown() - change the owner of a file."
0 
2 i_u $c C_integer i_u;  $e i_g $c C_integer i_g;  $e 
lst lst tcase2 1 3 
1 T8 call 0 n ____t f 0 0 1 $c C_integer (*i_u)  $e $c &($m3 )  $e 
1 T1 call 1 s ___et f 0 0 2 $c C_integer (*i_u)  $e $c &($m3 )  $e $c dptr u  $e $c &($r1 )  $e 
1 T0 call 2 n ____t f 0 0 2 $c C_integer (*i_u)  $e $c &($m3 )  $e $c dptr u  $e $c &($r1 )  $e 
runerr2 170 2 
tcase2 2 3 
1 T8 call 3 n ____t f 0 0 1 $c C_integer (*i_g)  $e $c &($m4 )  $e 
1 T1 call 4 s ___et f 0 0 2 $c C_integer (*i_g)  $e $c &($m4 )  $e $c dptr g  $e $c &($r2 )  $e 
1 T0 call 5 n ____t f 0 0 2 $c C_integer (*i_g)  $e $c &($m4 )  $e $c dptr g  $e $c &($r2 )  $e 
runerr2 170 1 
tcase2 0 2 
1 T13 lst abstr nil typ T8 
call 6 s fr_e_ t 0 0 3 $c C_integer i_g  $e $c $r4  $e $c C_integer i_u  $e $c $r3  $e $c dptr s  $e $c &($r0 )  $e 
1 T0 lst abstr nil typ T8 
call 7 s fr___ t 0 0 3 $c C_integer i_g  $e $c $r4  $e $c C_integer i_u  $e $c $r3  $e $c dptr s  $e $c &($r0 )  $e 
runerr2 109 0 
$end

chroot	5w 1(d)	{0,1} fr_e f 
"chroot() - change the root directory."
0 
0 
lst lst if1 ! cnv1 cs 0 
runerr2 103 0 
abstr nil typ T8 
block _ 0 $c CURTSTATE();
IntVal(amperErrno) = 0;
$cgoto $c !(chroot($r0 ) != 0)  $e 0 IntVal(amperErrno) = errno;
$fail $lbl 0 $ret d 1 $c nulldesc  $e  $e 
$end

classname	25 1(d)	{0,1} fr__ t 
"classname(r) - get name of class for instance r"
0 
0 
lst abstr nil typ T0 
call 0 s fr___ t 0 0 1 $c dptr r  $e $c &($r0 )  $e 
$end

close	2k 1(d)	{0,1} fr_e f 
"close(f) - close file f."
0 
0 
lst lst if1 ! is T13 0 
runerr2 105 0 
abstr nil ++ typ T13 typ T1 
call 0 s fr___ t 0 0 1 $c dptr f  $e $c &($r0 )  $e 
$end

cofail	19 1(d)	{0,1} fr_e t 
"cofail(CE) - transmit a co-expression failure to CE"
0 
0 
lst lst abstr nil typ a 
if2 is T8 0 
call 0 s ___et f 0 0 1 $c dptr CE  $e $c &($m0 )  $e 
if1 ! is T4 0 
runerr2 118 0 
call 1 s fr___ t 0 0 1 $c dptr CE  $e $c &($r0 )  $e 
$end

collect	0o 2(d,d)	{1,1} fr_e f 
"collect(i1,i2) - call garbage collector to ensure i2 bytes in region i1. no longer works."
0 
0 
lst lst lst if1 ! def1 ci 0 $c (C_integer)0  $e 
runerr2 101 0 
if1 ! def1 ci 1 $c (C_integer)0  $e 
runerr2 101 1 
abstr nil typ T8 
call 0 s fr_e_ t 0 0 2 $c C_integer region  $e $c $r0  $e $c C_integer bytes  $e $c $r1  $e 
$end

condvar	1e 1(dv)	{0,0} ___e f 
"an unavailable function"
0 
0 
runerr1 121 
$end

constructor	2i 2(d,dv)	{1,1} _r_e f 
"constructor(label, field, field...) - produce a new record constructor"
0 
0 
lst lst abstr nil typ T3 
if1 ! cnv1 T0 0 
runerr2 103 0 
block _ 0 $c ${ int i; 
struct b_proc *bp;
i = 0;
$lbl 0 $cgoto $c !(i < $r2 )  $e 2 $cgoto $c !(!(!(($r1 [i]).dword & F_Nqual)))  $e 3 err_msg(103, &($r1 [i]));
$efail $lbl 3 $lbl 1 i++;
$goto 0 $lbl 2 bp = dynrecord(&$m0 , $r1 , $r2 );
$cgoto $c !(bp == NULL)  $e 4 syserr("out of memory in constructor()");
$lbl 4 $ret T3 1 $c bp  $e $}  $e 
$end

copy	0p 1(d)	{1,1} _r_e t 
"copy(x) - make a copy of object x."
0 
0 
lst abstr nil vartyp 0 
tcase2 0 5 
1 T2 call 1 s _r_e_ t 0 0 1 $c dptr x  $e $c &($r0 )  $e 
1 T15 call 2 s _r_e_ t 0 0 1 $c dptr x  $e $c &($m0 )  $e 
1 T12 call 3 s _r_e_ t 0 0 1 $c dptr x  $e $c &($m0 )  $e 
1 T11 block _ 0 $c $cgoto $c BlkD($r0 , List)->listtail != NULL  $e 0 $cgoto $c BlkType(BlkD($r0 , List)->listhead) == T_Realarray  $e 1 $cgoto $c !(cpintarray(&$m0 , &$mr , (word)1, BlkD($r0 , List)->size + 1) == RunError)  $e 2 err_msg(0, NULL);
$efail $lbl 2 $goto 3 $lbl 1 $cgoto $c !(cprealarray(&$m0 , &$mr , (word)1, BlkD($r0 , List)->size + 1) == RunError)  $e 4 err_msg(0, NULL);
$efail $lbl 4 $lbl 3 $goto 5 $lbl 0 $cgoto $c !(cplist(&$m0 , &$mr , (word)1, BlkD($r0 , List)->size + 1) == RunError)  $e 6 err_msg(0, NULL);
$efail $lbl 6 $lbl 5 $ret rn 0  $e 
9 T14 T4 T3 T13 T10 T1 T9 T0 T8 block _ 0 $c $ret d 1 $c $r0  $e  $e 
call 0 n ___e_ f 0 0 1 $c dptr x  $e $c &($r0 )  $e 
$end

cos	09 1(d)	{1,1} _r_e f 
"cos(r), x in radians."
0 
0 
lst lst if1 ! cnv1 cd 0 
runerr2 102 0 
abstr nil typ T10 
block _ 0 $c ${ double y;
;
errno = 0;
y = cos($r0 );
;
$ret cd 1 $c y  $e $}  $e 
$end

crypt	6h 2(d,d)	{0,1} fr_e t 
"crypt() - the password encryption function."
0 
0 
lst lst lst if1 ! cnv1 cs 0 
runerr2 103 0 
if1 ! cnv1 cs 1 
runerr2 103 1 
abstr nil typ T0 
block _ 0 $c ${ char *s; 
char *crypt(const char *key, const char *salt);
CURTSTATE();
IntVal(amperErrno) = 0;
s = crypt($r0 , $r1 );
$cgoto $c !(s == NULL)  $e 0 IntVal(amperErrno) = errno;
$fail $lbl 0 $lbl 1 ${ int len = strlen(alcstr(s, strlen(s)));
$lbl 3 $cgoto $c !((StrLoc($rr ) = alcstr((alcstr(s, strlen(s))), len)) == NULL)  $e 5 err_msg(0, NULL);
$efail $lbl 5 $cgoto $c 0  $e 3 $lbl 4 StrLen($rr ) = len;
$} $cgoto $c 0  $e 1 $lbl 2 $ret rn 0 $}  $e 
$end

cset	01 1(d)	{0,1} fr__ f 
"cset(x) - produces a value of type cset resulting from the conversion of x, but fails if the conversion is not possible."
0 
0 
if2 cnv1 T9 0 
lst abstr nil typ T9 
block _ 0 $c $ret d 1 $c $r0  $e  $e 
lst abstr nil typ e 
block _ 0 $c $fail  $e 
$end

ctime	6k 1(d)	{0,1} _r_e t 
"ctime(t) - convert time_t (seconds since Jan 1, 1970 00:00:00) into ASCII."
0 
0 
lst lst if1 ! cnv1 ci 0 
runerr2 101 0 
abstr nil typ T0 
block _ 0 $c ${ int l; 
char *p;
$cgoto $c !((p = ctime((time_t *)&$m0 )) == NULL)  $e 0 err_msg(0, NULL);
$efail $lbl 0 l = strlen(p) - 1;
$lbl 1 $cgoto $c !((StrLoc($rr ) = alcstr(p, l)) == NULL)  $e 3 err_msg(0, NULL);
$efail $lbl 3 $cgoto $c 0  $e 1 $lbl 2 StrLen($rr ) = l;
$ret rn 0 $}  $e 
$end

dbcolumns	5e 2(d,d)	{} ___e f 
"an unavailable function"
0 
0 
runerr1 121 
$end

dbdriver	5f 1(d)	{} ___e f 
"an unavailable function"
0 
0 
runerr1 121 
$end

dbgbrk	5l 0()	{1,1} _r__ f 
"dbgbrk() - allow a convenient debugger break point called from Unicon code"
0 
0 
lst abstr nil typ T8 
call 0 n _r___ t 0 0 0 
$end

dbkeys	5g 2(d,d)	{} ___e f 
"an unavailable function"
0 
0 
runerr1 121 
$end

dblimits	5h 1(d)	{} ___e f 
"an unavailable function"
0 
0 
runerr1 121 
$end

dbproduct	5i 1(d)	{} ___e f 
"an unavailable function"
0 
0 
runerr1 121 
$end

dbtables	5k 1(d)	{} ___e f 
"an unavailable function"
0 
0 
runerr1 121 
$end

delay	32 1(d)	{0,1} fr_e f 
"delay(i) - delay for i milliseconds."
0 
0 
lst lst if1 ! cnv1 ci 0 
runerr2 101 0 
abstr nil typ T8 
block _ 0 $c $cgoto $c !(idelay($r0 ) == Failed)  $e 0 $fail $lbl 0 CURTSTATE();
pollctr >>= 1;
pollctr++;
$ret d 1 $c nulldesc  $e  $e 
$end

delete	20 2(d,dv)	{1,1} fr_e f 
"delete(x1, x2) - delete element x2 from set, table, or list x1 if it is there (always succeeds and returns x1)."
0 
0 
lst abstr nil ** vartyp 0 ++ ++ typ T15 typ T12 typ T11 
tcase2 0 4 
1 T13 call 0 s _r_e_ t 0 0 3 $c dptr x  $e $c $r1  $e $c int n  $e $c $r2  $e $c dptr s  $e $c &($r0 )  $e 
1 T11 call 1 s fr_e_ t 0 0 3 $c dptr x  $e $c $r1  $e $c int n  $e $c $r2  $e $c dptr s  $e $c &($m0 )  $e 
1 T12 call 2 n _r___ t 0 0 3 $c dptr x  $e $c $r1  $e $c int n  $e $c $r2  $e $c dptr s  $e $c &($r0 )  $e 
1 T15 call 3 n _r___ t 0 0 3 $c dptr x  $e $c $r1  $e $c int n  $e $c $r2  $e $c dptr s  $e $c &($r0 )  $e 
runerr2 122 0 
$end

detab	1m 2(d,dv)	{1,1} _r_e t 
"detab(s,i,...) - replace tabs with spaces, with stops at columns indicated."
0 
0 
lst lst if1 ! cnv1 T0 0 
runerr2 103 0 
abstr nil typ T0 
call 0 s _r_e_ t 0 0 3 $c dptr i  $e $c $m1  $e $c int n  $e $c $r2  $e $c dptr s  $e $c &($r0 )  $e 
$end

display	0q 2(d,d)	{1,1} _r_e f 
"display(i,f) - display local variables of i most recent procedure activations, plus global variables. Output to file f (default &errout)."
0 
0 
lst lst lst if1 ! def1 ci 0 $c (C_integer)k_level  $e 
runerr2 101 0 
if2 is T8 1 
block t 0 $c $m1 .dword = D_File;
BlkLoc($r1 ) = (union block *)&k_errout;  $e 
if1 ! is T13 1 
runerr2 105 1 
abstr nil typ T8 
call 0 s _r_e_ t 0 0 2 $c C_integer i  $e $c $m0  $e $c dptr f  $e $c &($r1 )  $e 
$end

dtor	0g 1(d)	{1,1} _r_e f 
"dtor(r) - convert x from degrees to radians."
0 
0 
lst lst if1 ! cnv1 cd 0 
runerr2 102 0 
abstr nil typ T10 
block _ 0 $c ${ double y;
;
errno = 0;
y = (($r0 ) * Pi / 180);
;
$ret cd 1 $c y  $e $}  $e 
$end

entab	1n 2(d,dv)	{1,1} _r_e t 
"entab(s,i,...) - replace spaces with tabs, with stops at columns indicated."
0 
0 
lst lst if1 ! cnv1 T0 0 
runerr2 103 0 
abstr nil typ T0 
call 0 s _r_e_ t 0 0 3 $c dptr s  $e $c &($r0 )  $e $c dptr i  $e $c $m1  $e $c int n  $e $c $r2  $e 
$end

errorclear	0r 0()	{1,1} _r__ f 
"errorclear() - clear error condition."
0 
0 
lst abstr nil typ T8 
call 0 n _r___ t 0 0 0 
$end

exec	68 2(d,dv)	{0,1} fr_e f 
"exec() - replace the executing Icon program with a new program."
0 
0 
lst lst if1 ! cnv1 cs 0 
runerr2 103 0 
abstr nil typ T8 
call 0 s fr_e_ t 0 0 3 $c dptr f  $e $c &($rd0 )  $e $c dptr argv  $e $c $r1  $e $c int argc  $e $c $r2  $e 
$end

exit	2l 1(d)	{} ___e f 
"exit(i) - exit process with status i, which defaults to 0."
0 
0 
lst if1 ! def1 ci 0 $c EXIT_SUCCESS  $e 
runerr2 101 0 
block _ 0 $c c_exit((int)$r0 );  $e 
$end

exp	0e 1(d)	{1,1} _r_e f 
"exp(r) - e^x."
0 
0 
lst lst if1 ! cnv1 cd 0 
runerr2 102 0 
abstr nil typ T10 
block _ 0 $c ${ double y;
;
errno = 0;
y = exp($r0 );
$cgoto $c !(errno == ERANGE)  $e 0 err_msg(204, NULL);
$efail $lbl 0 $ret cd 1 $c y  $e $}  $e 
$end

fcntl	61 3(d,d,d)	{0,1} fr_e t 
"fcntl() - control a file."
0 
0 
lst lst lst lst if1 ! is T0 1 
runerr2 103 1 
if1 ! is T13 0 
runerr2 105 0 
if1 ! is T0 2 
if1 ! is T1 2 
runerr2 1044 2 
abstr nil ++ ++ typ T0 typ T2 typ T1 
call 0 s fr_e_ t 0 0 3 $c dptr options  $e $c &($r2 )  $e $c dptr action  $e $c &($r1 )  $e $c dptr f  $e $c &($r0 )  $e 
$end

fdup	67 2(d,d)	{0,1} fr_e f 
"fdup() - duplicate a file (including its Unix fd)."
0 
0 
lst lst lst if1 ! is T13 0 
runerr2 105 0 
if1 ! is T13 1 
runerr2 105 1 
abstr nil typ T8 
call 0 s fr_e_ t 0 0 2 $c dptr dest  $e $c &($r1 )  $e $c dptr src  $e $c &($r0 )  $e 
$end

fetch	6s 2(d,d)	{0,1} fr_e t 
"fetch() - fetch a value from a dbm database."
0 
0 
lst lst if1 ! is T13 0 
runerr2 190 0 
abstr nil ++ typ T0 typ T2 
call 0 s fr_e_ t 0 0 2 $c dptr k  $e $c &($r1 )  $e $c dptr d  $e $c &($r0 )  $e 
$end

fieldnames	18 1(d)	{0,*} f_se f 
"fieldnames(r) - generate the fieldnames of record r"
0 
0 
lst lst abstr nil typ T0 
if1 ! is T2 0 
runerr2 107 0 
call 0 s f_s__ t 0 0 1 $c dptr r  $e $c &($r0 )  $e 
$end

filepair	64 0()	{0,1} fr_e f 
"filepair() - create a connected bidirectional pair of files."
0 
0 
lst abstr nil new T11 1 typ T13 
call 0 s fr_e_ t 0 0 0 
$end

find	1w 4(d,d,d,d)	{0,*} f_se f 
"find(s1,s2,i1,i2) - generates the sequence of positions in s2 at which s1 occurs as a substring in s2[i1:i2], but fails if there is no such position."
0 
2 cnv_i $c C_integer cnv_i;  $e cnv_j $c C_integer cnv_j;  $e 
lst lst lst lst lst abstr nil typ T1 
if2 is T8 1 
lst block t 0 $c CURTSTATE();
$m1 = k_subject;  $e 
if1 is T8 2 
block t 0 $c CURTSTATE();
$m4 = k_pos;  $e 
lst if1 ! cnv1 T0 1 
runerr2 103 1 
if1 is T8 2 
block t 0 $c $m4 = 1;  $e 
if1 ! is T8 2 
if2 cnv2 ci 2 $c $m4  $e 
block t 0 $c $cgoto $c !(($m4 = cvpos($r4 , StrLen($r1 ))) == CvtFail)  $e 0 $fail $lbl 0  $e 
runerr2 101 2 
if2 is T8 3 
block t 0 $c $m5 = StrLen($r1 ) + 1;  $e 
if2 cnv2 ci 3 $c $m5  $e 
block t 0 $c $cgoto $c !(($m5 = cvpos($r5 , StrLen($r1 ))) == CvtFail)  $e 1 $fail $lbl 1 $cgoto $c !($r4 > $r5 )  $e 2 ${ register C_integer tmp;
tmp = $r4 ;
$m4 = $r5 ;
$m5 = tmp;
$} $lbl 2  $e 
runerr2 101 3 
if1 ! cnv1 T0 0 
runerr2 103 0 
call 0 s f_s__ t 0 0 4 $c dptr s2  $e $c &($r1 )  $e $c C_integer cnv_i  $e $c $m4  $e $c C_integer cnv_j  $e $c $r5  $e $c dptr s1  $e $c &($r0 )  $e 
$end

flock	60 2(d,d)	{0,1} fr_e f 
"flock() - apply or remove a lock on a file."
1 str nil 
0 
lst lst lst if1 ! cnv2 cs 1 $c $m2  $e 
runerr2 101 1 
if1 ! is T13 0 
runerr2 105 0 
abstr nil typ T8 
call 0 s fr_e_ t 0 0 3 $c dptr cmd  $e $c &($r1 )  $e $c dptr c  $e $c &($rd2 )  $e $c dptr f  $e $c &($r0 )  $e 
$end

flush	33 1(d)	{1,1} _r_e f 
"flush(f) - flush file f."
0 
0 
lst lst if1 ! is T13 0 
runerr2 105 0 
abstr nil vartyp 0 
call 0 n _r___ t 0 0 1 $c dptr f  $e $c &($r0 )  $e 
$end

fork	66 0()	{0,1} fr__ f 
"fork() - spawn a new identical process."
0 
0 
lst abstr nil typ T1 
block _ 0 $c ${ int pid;
CURTSTATE();
IntVal(amperErrno) = 0;
$cgoto $c !((pid = fork()) < 0)  $e 0 IntVal(amperErrno) = errno;
$fail $lbl 0 $ret ci 1 $c pid  $e $}  $e 
$end

get	21 2(d,d)	{0,1} fr_e t 
"get(x) - get an element from the left end of list x."
0 
0 
lst if1 ! def1 ci 1 $c 1L  $e 
runerr2 101 1 
tcase2 0 2 
1 T13 lst abstr nil typ T0 
call 0 s fr_e_ t 0 0 1 $c dptr x  $e $c &($r0 )  $e 
1 T11 lst abstr nil store . vartyp 0 C3 
call 1 s fr___ t 0 0 2 $c dptr x  $e $c &($m0 )  $e $c C_integer i  $e $c $r1  $e 
runerr2 108 0 
$end

getch	2y 0()	{0,1} fr__ f 
"getch() - return a character from console."
0 
0 
lst abstr nil typ T0 
call 0 s fr___ t 0 0 0 
$end

getche	2z 0()	{0,1} fr__ f 
"getche() -- return a character from console with echo."
0 
0 
lst abstr nil typ T0 
call 0 s fr___ t 0 0 0 
$end

getegid	6c 0()	{0,1} _r_e t 
"getegid() - get the effective group identity."
0 
0 
lst abstr nil typ T0 
call 0 s _r_e_ t 0 0 0 
$end

getenv	2m 1(d)	{0,1} fr_e f 
"getenv(s) - return contents of environment variable s."
0 
0 
lst lst if1 ! cnv1 cs 0 
runerr2 103 0 
abstr nil typ T0 
block _ 0 $c ${ char *p, *sbuf; 
long l;
$cgoto $c (sbuf = getenv_var($r0 )) != NULL  $e 0 set_syserrortext(errno);
$fail $goto 1 $lbl 0 l = strlen(sbuf);
$lbl 2 $cgoto $c !((p = alcstr(sbuf, l)) == NULL)  $e 4 err_msg(0, NULL);
$efail $lbl 4 $cgoto $c 0  $e 2 $lbl 3 free(sbuf);
$ret T0 2 $c l  $e $c p  $e $lbl 1 $}  $e 
$end

geteuid	6a 0()	{0,1} _r_e t 
"geteuid() - get the effective user identity."
0 
0 
lst abstr nil typ T0 
call 0 s _r_e_ t 0 0 0 
$end

getgid	6b 0()	{0,1} _r_e t 
"getgid() - get the real group identity."
0 
0 
lst abstr nil typ T0 
call 0 s _r_e_ t 0 0 0 
$end

getgr	6v 1(d)	{0,1} fr_e t 
"getgr() - get group information."
0 
3 gr $c struct group *gr;  $e grbuf $c struct group grbuf;  $e buf $c char buf[4096];  $e 
lst abstr nil typ T2 
tcase2 0 3 
1 T8 call 0 s fr___ t 0 0 2 $c struct group (*grbuf)  $e $c &($m2 )  $e $c struct group *gr  $e $c $m1  $e 
1 T1 call 1 s fr_e_ t 0 0 4 $c struct group *gr  $e $c $m1  $e $c char buf[4096]  $e $c $r3  $e $c struct group (*grbuf)  $e $c &($m2 )  $e $c dptr g  $e $c &($r0 )  $e 
1 T0 call 2 s fr___ t 0 0 4 $c struct group *gr  $e $c $m1  $e $c char buf[4096]  $e $c $r3  $e $c struct group (*grbuf)  $e $c &($m2 )  $e $c dptr g  $e $c &($r0 )  $e 
runerr2 170 0 
$end

gethost	6w 2(d,d)	{0,1} fr_e t 
"gethost() - get host information."
0 
1 hs $c struct hostent *hs;  $e 
lst abstr nil typ T2 
tcase2 0 3 
1 T13 call 0 s fr_e_ t 0 0 1 $c dptr h  $e $c &($r0 )  $e 
1 T8 call 1 s fr___ t 0 0 1 $c struct hostent *hs  $e $c $m2  $e 
1 T0 call 2 s fr_e_ t 0 0 2 $c dptr f  $e $c &($r1 )  $e $c dptr h  $e $c &($r0 )  $e 
runerr2 103 0 
$end

getpgrp	6f 0()	{0,1} _r__ f 
"getpgrp() - get the process group."
0 
0 
lst abstr nil typ T1 
block _ 0 $c $ret ci 1 $c getpgrp()  $e  $e 
$end

getpid	5o 0()	{0,1} _r__ f 
"getpid() - get process pid."
0 
0 
lst abstr nil typ T1 
block _ 0 $c CURTSTATE();
IntVal(amperErrno) = 0;
$ret ci 1 $c (getpid())  $e  $e 
$end

getppid	5n 0()	{0,1} _r__ f 
"getppid() - get parent pid."
0 
0 
lst abstr nil typ T1 
call 0 i _r___ f 0 0 0 
$end

getpw	6u 1(d)	{0,1} fr_e t 
"getpw() - get password file information."
0 
3 pw $c struct passwd *pw;  $e pwbuf $c struct passwd pwbuf;  $e buf $c char buf[1024];  $e 
lst abstr nil typ T2 
tcase2 0 3 
1 T8 call 0 s fr___ t 0 0 1 $c struct passwd *pw  $e $c $m1  $e 
1 T1 call 1 s fr_e_ t 0 0 4 $c struct passwd *pw  $e $c $m1  $e $c char buf[1024]  $e $c $r3  $e $c struct passwd (*pwbuf)  $e $c &($m2 )  $e $c dptr u  $e $c &($r0 )  $e 
1 T0 call 2 s fr___ t 0 0 4 $c struct passwd *pw  $e $c $m1  $e $c char buf[1024]  $e $c $r3  $e $c struct passwd (*pwbuf)  $e $c &($m2 )  $e $c dptr u  $e $c &($r0 )  $e 
runerr2 170 0 
$end

getrusage	6n 1(d)	{0,1} fr_e t 
"getrusage() - get resource usage."
0 
0 
lst lst if1 ! def1 cs 0 $c "self"  $e 
runerr2 103 0 
abstr nil typ T2 
call 0 s fr_e_ t 0 0 1 $c dptr who  $e $c &($rd0 )  $e 
$end

getserv	6x 2(d,d)	{0,1} fr_e t 
"getserv() - get network service information."
0 
1 serv $c struct servent *serv;  $e 
lst abstr nil typ T2 
tcase2 0 3 
1 T8 call 0 s fr___ t 0 0 1 $c struct servent *serv  $e $c $m2  $e 
1 T1 call 1 s fr_e_ t 0 0 3 $c struct servent *serv  $e $c $m2  $e $c dptr proto  $e $c &($r1 )  $e $c dptr s  $e $c &($r0 )  $e 
1 T0 call 2 s fr_e_ t 0 0 2 $c dptr proto  $e $c &($r1 )  $e $c dptr s  $e $c &($r0 )  $e 
runerr2 170 0 
$end

gettimeofday	6m 0()	{0,1} fr_e t 
"gettimeofday() - get time since the epoch (Jan 1, 1970 00:00:00)."
0 
0 
lst abstr nil typ T2 
call 0 s fr_e_ t 0 0 0 
$end

getuid	69 0()	{0,1} _r_e t 
"getuid() - get the real user identity."
0 
0 
lst abstr nil typ T0 
call 0 s _r_e_ t 0 0 0 
$end

gtime	6l 1(d)	{0,1} _r_e t 
"gtime(t) - convert time_t (seconds since Jan 1, 1970 00:00:00) into UTC."
0 
0 
lst lst if1 ! cnv1 ci 0 
runerr2 101 0 
abstr nil typ T0 
block _ 0 $c ${ int l; 
char *p;
p = asctime(gmtime((time_t *)&$m0 ));
l = strlen(p) - 1;
$lbl 0 $cgoto $c !((StrLoc($rr ) = alcstr(p, l)) == NULL)  $e 2 err_msg(0, NULL);
$efail $lbl 2 $cgoto $c 0  $e 0 $lbl 1 StrLen($rr ) = l;
$ret rn 0 $}  $e 
$end

hardlink	5p 2(d,d)	{0,1} fr_e f 
"hardlink() - create a link to a file."
0 
0 
lst lst lst if1 ! cnv1 cs 0 
runerr2 103 0 
if1 ! cnv1 cs 1 
runerr2 103 1 
abstr nil typ T8 
block _ 0 $c CURTSTATE();
IntVal(amperErrno) = 0;
$cgoto $c !(link($r0 , $r1 ) != 0)  $e 0 IntVal(amperErrno) = errno;
$fail $lbl 0 $ret d 1 $c nulldesc  $e  $e 
$end

iand	0s 2(d,d)	{1,1} _r_e t 
"iand(i,j) - produce bitwise AND of i and j."
0 
0 
lst lst lst if1 ! cnv1 T1 0 
runerr2 101 0 
if1 ! cnv1 T1 1 
runerr2 101 1 
abstr nil typ T1 
block _ 0 $c $cgoto $c (Type($r0 ) == T_Lrgint) || (Type($r1 ) == T_Lrgint)  $e 0 $ret ci 1 $c IntVal($r0 ) & IntVal($r1 )  $e $goto 1 $lbl 0 $cgoto $c !(bigand(&$m0 , &$m1 , &$mr ) == RunError)  $e 2 err_msg(0, NULL);
$efail $lbl 2 $ret rn 0 ;
$lbl 1  $e 
$end

icom	0v 1(d)	{1,1} _r_e t 
"icom(i) - produce bitwise complement (one's complement) of i."
0 
0 
lst lst if1 ! cnv1 T1 0 
runerr2 101 0 
abstr nil typ T1 
block _ 0 $c $cgoto $c Type($r0 ) == T_Lrgint  $e 0 $ret ci 1 $c ~IntVal($r0 )  $e $goto 1 $lbl 0 ${ struct descrip td;
td.dword = D_Integer;
IntVal(td) = -1;
$cgoto $c !(bigsub(&td, &$m0 , &$mr ) == RunError)  $e 2 err_msg(0, NULL);
$efail $lbl 2 $ret rn 0 $} $lbl 1  $e 
$end

image	0x 1(d)	{1,1} _r_e t 
"image(x) - return string image of object x."
0 
0 
lst abstr nil typ T0 
call 0 s _r_e_ t 0 0 1 $c dptr x  $e $c &($m0 )  $e 
$end

insert	24 2(d,dv)	{1,1} fr_e f 
"insert(x1, x2, x3) - insert element x2 into set or table x1 if not already there. If x1 is a table, the assigned value for element x2 is x3. (always succeeds and returns x1)."
0 
0 
tcase2 0 4 
1 T13 lst abstr nil typ T0 
call 0 s fr_e_ t 0 0 3 $c dptr s  $e $c &($r0 )  $e $c dptr x  $e $c $m1  $e $c int n  $e $c $r2  $e 
1 T12 lst abstr lst = . vartyp 0 C4 . vartyp 1 C3 
= . vartyp 0 C5 . vartyp 1 C3 vartyp 0 
call 1 s _r_e_ t 0 0 3 $c dptr x  $e $c $r1  $e $c int n  $e $c $r2  $e $c dptr s  $e $c &($r0 )  $e 
1 T11 lst abstr = . vartyp 0 C3 . vartyp 1 C3 vartyp 0 
call 2 s fr_e_ t 0 0 3 $c dptr x  $e $c $m1  $e $c int n  $e $c $r2  $e $c dptr s  $e $c &($m0 )  $e 
1 T15 lst abstr = . vartyp 0 C8 . vartyp 1 C3 vartyp 0 
call 3 s _r_e_ t 0 0 3 $c dptr x  $e $c $r1  $e $c int n  $e $c $r2  $e $c dptr s  $e $c &($r0 )  $e 
runerr2 122 0 
$end

integer	02 1(d)	{0,1} fr__ f 
"integer(x) - produces a value of type integer resulting from the conversion of x, but fails if the conversion is not possible."
0 
0 
if2 cnv1 T1 0 
lst abstr nil typ T1 
block _ 0 $c $ret d 1 $c $r0  $e  $e 
lst abstr nil typ e 
block _ 0 $c $fail  $e 
$end

ioctl	63 3(d,d,d)	{0,0} f__e f 
"ioctl() - control a device driver."
0 
0 
lst lst lst if1 ! cnv1 ci 1 
runerr2 103 1 
if1 ! is T13 0 
runerr2 105 0 
abstr nil typ T1 
block _ 0 $c ${ int fd;
CURTSTATE();
IntVal(amperErrno) = 0;
$cgoto $c !((fd = get_fd($r0 , 0)) < 0)  $e 0 err_msg(174, &($r0 ));
$efail $lbl 0 $cgoto $c !(BlkD($r0 , File)->status & Fs_Compress)  $e 1 $fail $lbl 1 err_msg(121, &($r0 ));
$efail $}  $e 
$end

ior	0t 2(d,d)	{1,1} _r_e t 
"ior(i,j) - produce bitwise inclusive OR of i and j."
0 
0 
lst lst lst if1 ! cnv1 T1 0 
runerr2 101 0 
if1 ! cnv1 T1 1 
runerr2 101 1 
abstr nil typ T1 
block _ 0 $c $cgoto $c (Type($r0 ) == T_Lrgint) || (Type($r1 ) == T_Lrgint)  $e 0 $ret ci 1 $c IntVal($r0 ) | IntVal($r1 )  $e $goto 1 $lbl 0 $cgoto $c !(bigor(&$m0 , &$m1 , &$mr ) == RunError)  $e 2 err_msg(0, NULL);
$efail $lbl 2 $ret rn 0 ;
$lbl 1  $e 
$end

ishift	0y 2(d,d)	{1,1} _r_e t 
"ishift(i,j) - produce i shifted j bit positions (left if j<0, right if j>0)."
0 
0 
lst lst lst if1 ! cnv1 T1 0 
runerr2 101 0 
if1 ! cnv1 T1 1 
runerr2 101 1 
abstr nil typ T1 
call 0 s _r_e_ t 0 0 2 $c dptr i  $e $c &($m0 )  $e $c dptr j  $e $c &($m1 )  $e 
$end

ixor	0u 2(d,d)	{1,1} _r_e t 
"ixor(i,j) - produce bitwise exclusive OR of i and j."
0 
0 
lst lst lst if1 ! cnv1 T1 0 
runerr2 101 0 
if1 ! cnv1 T1 1 
runerr2 101 1 
abstr nil typ T1 
block _ 0 $c $cgoto $c (Type($r0 ) == T_Lrgint) || (Type($r1 ) == T_Lrgint)  $e 0 $ret ci 1 $c IntVal($r0 ) ^ IntVal($r1 )  $e $goto 1 $lbl 0 $cgoto $c !(bigxor(&$m0 , &$m1 , &$mr ) == RunError)  $e 2 err_msg(0, NULL);
$efail $lbl 2 $ret rn 0 ;
$lbl 1  $e 
$end

kbhit	30 0()	{0,1} fr__ f 
"kbhit() -- Check to see if there is a keyboard character waiting to be read."
0 
0 
lst abstr nil typ T8 
block _ 0 $c $cgoto $c kbhit()  $e 0 $fail $goto 1 $lbl 0 $ret d 1 $c nulldesc  $e $lbl 1  $e 
$end

key	23 1(d)	{0,*} f_se t 
"key(T) - generate successive keys (entry values) from table T."
0 
0 
tcase2 0 4 
1 T13 lst abstr nil typ T0 
block _ 0 $c ${ word status;
status = BlkD($r0 , File)->status;
$cgoto $c status & Fs_Dbm  $e 1 $cgoto $c status & Fs_Messaging  $e 2 err_msg(122, &($r0 ));
$efail $goto 3 $lbl 2 ${ struct MFile *mf = BlkD($r0 , File)->fd.mf; 
char *field, *end;
$cgoto $c !((mf->resp == NULL) && !MFIN(mf, READING))  $e 4 Mstartreading(mf);
$lbl 4 $cgoto $c !(mf->resp == NULL)  $e 5 $fail $lbl 5 $lbl 6 $cgoto $c !((StrLoc($rr ) = alcstr("Status-Code", 11)) == NULL)  $e 8 err_msg(0, NULL);
$efail $lbl 8 $cgoto $c 0  $e 6 $lbl 7 StrLen($rr ) = 11;
$susp rn 0 $cgoto $c !(mf->resp->msg != NULL && strlen(mf->resp->msg) > 0)  $e 9 $lbl 10 $cgoto $c !((StrLoc($rr ) = alcstr("Reason-Phrase", 13)) == NULL)  $e 12 err_msg(0, NULL);
$efail $lbl 12 $cgoto $c 0  $e 10 $lbl 11 StrLen($rr ) = 13;
$susp rn 0 $lbl 9 $cgoto $c !(mf->resp->header == NULL)  $e 13 $fail $lbl 13 field = mf->resp->header;
$lbl 14 $cgoto $c !(field != NULL)  $e 16 $lbl 17 $cgoto $c !(strchr(" \r\n", *field))  $e 18 field++;
$goto 17 $lbl 18 end = strchr(field, ':');
$lbl 19 $cgoto $c !((StrLoc($rr ) = alcstr(field, end - field)) == NULL)  $e 21 err_msg(0, NULL);
$efail $lbl 21 $cgoto $c 0  $e 19 $lbl 20 StrLen($rr ) = end - field;
$susp rn 0 $lbl 15 field = strchr(field, '\r');
$goto 14 $lbl 16 $fail $} $lbl 3 $goto 22 $lbl 1 ${ DBM *db; 
datum key;
db = BlkD($r0 , File)->fd.dbm;
key = dbm_firstkey(db);
$lbl 23 $cgoto $c !(key.dptr != NULL)  $e 25 $lbl 26 $cgoto $c !((StrLoc($rr ) = alcstr(key.dptr, key.dsize)) == NULL)  $e 28 err_msg(0, NULL);
$efail $lbl 28 $cgoto $c 0  $e 26 $lbl 27 StrLen($rr ) = key.dsize;
$susp rn 0 $lbl 24 key = dbm_nextkey(db);
$goto 23 $lbl 25 $fail $} $lbl 22 $}  $e 
1 T2 lst abstr nil typ T0 
block _ 0 $c ${ C_integer i = 0, sz = Blk(BlkD($r0 , Record)->recdesc, Proc)->nfields;
$cgoto $c !(sz > 0)  $e 29 ${ struct descrip d;
d = Blk(BlkD($r0 , Record)->recdesc, Proc)->lnames[0];
$cgoto $c !((StrLen(d) != 3) || strncmp(StrLoc(d), "__s", 3))  $e 30 $susp d 1 $c d  $e $lbl 30 $cgoto $c !(sz > 1)  $e 31 d = Blk(BlkD($r0 , Record)->recdesc, Proc)->lnames[1];
$cgoto $c !((StrLen(d) != 3) || strncmp(StrLoc(d), "__m", 3))  $e 32 $susp d 1 $c Blk(BlkD($r0 , Record)->recdesc, Proc)->lnames[1]  $e $lbl 32 i = 2;
$lbl 33 $cgoto $c !(i < sz)  $e 34 $susp d 1 $c Blk(BlkD($r0 , Record)->recdesc, Proc)->lnames[i]  $e i++;
$goto 33 $lbl 34 $lbl 31 $} $lbl 29 $fail $}  $e 
1 T11 lst abstr nil typ T1 
block _ 0 $c ${ C_integer i;
i = 1;
$lbl 35 $cgoto $c !(i <= BlkD($r0 , List)->size)  $e 37 $susp ci 1 $c i  $e $lbl 36 i++;
$goto 35 $lbl 37 $fail $}  $e 
1 T12 lst abstr nil store . vartyp 0 C4 
block _ 1 blkptr $c ${ struct hgstate state;
;
$t0 .vword.bptr = hgfirst(BlkLoc($r0 ), &state);
$lbl 38 $cgoto $c !($t0 .vword.bptr != 0)  $e 40 ;
$susp d 1 $c $t0 .vword.bptr->Telem.tref  $e $lbl 39 $t0 .vword.bptr = hgnext(BlkLoc($r0 ), &state, $t0 .vword.bptr);
$goto 38 $lbl 40 $fail $}  $e 
runerr2 124 0 
$end

kill	5s 2(d,d)	{0,1} fr_e f 
"kill() - send a signal to a process."
0 
0 
lst lst lst if1 ! is T0 1 
if1 ! is T1 1 
runerr2 170 1 
if1 ! cnv1 ci 0 
runerr2 101 0 
abstr nil typ T8 
call 0 s fr_e_ t 0 0 2 $c C_integer pid  $e $c $r0  $e $c dptr signal  $e $c &($r1 )  $e 
$end

left	1o 3(d,d,d)	{1,1} _r_e f 
"left(s1,i,s2) - pad s1 on right with s2 to length i."
0 
0 
lst lst lst lst if1 ! cnv1 T0 0 
runerr2 103 0 
if1 ! def1 ci 1 $c 1  $e 
runerr2 101 1 
if1 ! def1 ts 2 $c blank  $e 
runerr2 103 2 
abstr nil typ T0 
call 0 s _r_e_ t 0 0 3 $c dptr s1  $e $c &($r0 )  $e $c dptr s2  $e $c &($m2 )  $e $c C_integer n  $e $c $r1  $e 
$end

list	2b 2(d,d)	{1,1} _r_e f 
"list(i, x) - create a list of size i, with initial value x."
0 
0 
if2 is T15 0 
lst abstr nil new T11 1 store . vartyp 0 C8 
call 0 n _r___ t 0 0 1 $c dptr n  $e $c &($m0 )  $e 
if2 is T11 0 
lst abstr nil vartyp 0 
block _ 0 $c $ret d 1 $c listtoarray(&$m0 )  $e  $e 
lst lst if1 ! def1 ci 0 $c 0L  $e 
runerr2 101 0 
abstr nil new T11 1 vartyp 1 
call 1 s _r_e_ t 0 0 2 $c dptr x  $e $c &($r1 )  $e $c C_integer n  $e $c $r0  $e 
$end

loadfunc	07 2(d,d)	{0,1} _r_e t 
"loadfunc(filename,funcname) - load C function dynamically."
0 
0 
lst lst lst if1 ! cnv1 cs 0 
runerr2 103 0 
if1 ! cnv1 cs 1 
runerr2 103 1 
abstr nil typ T3 
call 0 s _r_e_ t 0 0 2 $c dptr funcname  $e $c &($rd1 )  $e $c dptr filename  $e $c &($rd0 )  $e 
$end

lock	1b 1(dv)	{0,0} ___e f 
"an unavailable function"
0 
0 
runerr1 121 
$end

log	0j 2(d,d)	{1,1} _r_e f 
"log(r1,r2) - logarithm of r1 to base r2."
0 
0 
lst lst lst if1 ! cnv1 cd 0 
runerr2 102 0 
abstr nil typ T10 
block t 0 $c $cgoto $c !($r0 <= 0.0)  $e 0 drunerr(205, $r0 );
$efail $lbl 0  $e 
if2 is T8 1 
block _ 0 $c $ret cd 1 $c log($r0 )  $e  $e 
lst if1 ! cnv1 cd 1 
runerr2 102 1 
call 0 s _r_e_ t 0 0 2 $c double x  $e $c $m0  $e $c double b  $e $c $r1  $e 
$end

lstat	6o 1(d)	{0,1} fr_e t 
"lstat() - get file status without following symlinks."
0 
0 
lst lst if1 ! cnv1 cs 0 
runerr2 103 0 
abstr nil typ T2 
call 0 s fr_e_ t 0 0 1 $c dptr f  $e $c &($rd0 )  $e 
$end

many	1x 4(d,d,d,d)	{0,1} fr_e f 
"many(c,s,i1,i2) - produces the position in s after the longest initial sequence of characters in c in s[i1:i2] but fails if there is none."
0 
2 cnv_i $c C_integer cnv_i;  $e cnv_j $c C_integer cnv_j;  $e 
lst lst lst lst lst abstr nil typ T1 
if2 is T8 1 
lst block t 0 $c CURTSTATE();
$m1 = k_subject;  $e 
if1 is T8 2 
block t 0 $c CURTSTATE();
$m4 = k_pos;  $e 
lst if1 ! cnv1 T0 1 
runerr2 103 1 
if1 is T8 2 
block t 0 $c $m4 = 1;  $e 
if1 ! is T8 2 
if2 cnv2 ci 2 $c $m4  $e 
block t 0 $c $cgoto $c !(($m4 = cvpos($r4 , StrLen($r1 ))) == CvtFail)  $e 0 $fail $lbl 0  $e 
runerr2 101 2 
if2 is T8 3 
block t 0 $c $m5 = StrLen($r1 ) + 1;  $e 
if2 cnv2 ci 3 $c $m5  $e 
block t 0 $c $cgoto $c !(($m5 = cvpos($r5 , StrLen($r1 ))) == CvtFail)  $e 1 $fail $lbl 1 $cgoto $c !($r4 > $r5 )  $e 2 ${ register C_integer tmp;
tmp = $r4 ;
$m4 = $r5 ;
$m5 = tmp;
$} $lbl 2  $e 
runerr2 101 3 
if1 ! cnv1 tc 0 
runerr2 104 0 
call 0 s fr___ t 0 0 4 $c dptr c  $e $c &($r0 )  $e $c dptr s  $e $c &($r1 )  $e $c C_integer cnv_j  $e $c $r5  $e $c C_integer cnv_i  $e $c $m4  $e 
$end

map	1p 3(d,d,d)	{1,1} _r_e t 
"map(s1,s2,s3) - map s1, using s2 and s3."
0 
0 
lst lst lst lst if1 ! cnv1 T0 0 
runerr2 103 0 
if1 ! def1 T0 1 $c ucase  $e 
runerr2 103 1 
if1 ! def1 T0 2 $c lcase  $e 
runerr2 103 2 
abstr nil typ T0 
call 0 s _r_e_ t 0 0 3 $c dptr s1  $e $c &($r0 )  $e $c dptr s3  $e $c &($r2 )  $e $c dptr s2  $e $c &($r1 )  $e 
$end

match	1y 4(d,d,d,d)	{0,1} fr_e f 
"match(s1,s2,i1,i2) - produces i1+*s1 if s1==s2[i1+:*s1], but fails otherwise."
0 
2 cnv_i $c C_integer cnv_i;  $e cnv_j $c C_integer cnv_j;  $e 
lst lst lst lst lst abstr nil typ T1 
if2 is T8 1 
lst block t 0 $c CURTSTATE();
$m1 = k_subject;  $e 
if1 is T8 2 
block t 0 $c CURTSTATE();
$m4 = k_pos;  $e 
lst if1 ! cnv1 T0 1 
runerr2 103 1 
if1 is T8 2 
block t 0 $c $m4 = 1;  $e 
if1 ! is T8 2 
if2 cnv2 ci 2 $c $m4  $e 
block t 0 $c $cgoto $c !(($m4 = cvpos($r4 , StrLen($r1 ))) == CvtFail)  $e 0 $fail $lbl 0  $e 
runerr2 101 2 
if2 is T8 3 
block t 0 $c $m5 = StrLen($r1 ) + 1;  $e 
if2 cnv2 ci 3 $c $m5  $e 
block t 0 $c $cgoto $c !(($m5 = cvpos($r5 , StrLen($r1 ))) == CvtFail)  $e 1 $fail $lbl 1 $cgoto $c !($r4 > $r5 )  $e 2 ${ register C_integer tmp;
tmp = $r4 ;
$m4 = $r5 ;
$m5 = tmp;
$} $lbl 2  $e 
runerr2 101 3 
if1 ! cnv1 ts 0 
runerr2 103 0 
call 0 s fr___ t 0 0 4 $c dptr s2  $e $c &($r1 )  $e $c dptr s1  $e $c &($r0 )  $e $c C_integer cnv_i  $e $c $r4  $e $c C_integer cnv_j  $e $c $m5  $e 
$end

max	0k 1(dv)	{1,1} fr_e f 
"max(x,y,...) - return the maximum of the arguments"
0 
0 
lst abstr nil typ a 
call 0 s fr___ t 0 0 2 $c dptr argv  $e $c $r0  $e $c int argc  $e $c $r1  $e 
$end

member	2c 2(d,dv)	{0,1} fr_e f 
"member(x1, x2) - returns x1 if x2 ... are members of x1 but fails otherwise.x1 may be a set, cset, table, list, database file or record."
0 
0 
tcase2 0 6 
1 T13 lst abstr nil typ T0 
call 0 s fr_e_ t 0 0 3 $c dptr s  $e $c &($r0 )  $e $c dptr x  $e $c $m1  $e $c int n  $e $c $r2  $e 
1 T9 lst abstr nil typ T9 
call 1 s fr___ t 0 0 3 $c dptr s  $e $c &($r0 )  $e $c dptr x  $e $c $m1  $e $c int n  $e $c $r2  $e 
1 T11 lst abstr nil store . vartyp 1 C3 
block _ 0 $c ${ int argc, size; 
C_integer cnv_x;
size = BlkD($r0 , List)->size;
argc = 0;
$lbl 1 $cgoto $c !(argc < $r2 )  $e 3 $cgoto $c !(!(cnv_c_int(&($r1 [argc]), &(cnv_x))))  $e 4 $fail $lbl 4 cnv_x = cvpos(cnv_x, size);
$cgoto $c !((cnv_x == CvtFail) || (cnv_x > size))  $e 5 $fail $lbl 5 $lbl 2 argc++;
$goto 1 $lbl 3 $ret d 1 $c $r1 [$r2 - 1]  $e $}  $e 
1 T12 lst abstr nil ** vartyp 1 store . vartyp 0 C4 
block _ 0 $c ${ int res, argc; 
register uword hn;
argc = 0;
$lbl 6 $cgoto $c !(argc < $r2 )  $e 8 ;
;
hn = hash($r1 + argc);
memb(BlkLoc($r0 ), $r1 + argc, hn, &res);
$cgoto $c !(res == 0)  $e 9 $fail $lbl 9 $lbl 7 argc++;
$goto 6 $lbl 8 $ret d 1 $c $r1 [$r2 - 1]  $e $}  $e 
1 T15 lst abstr nil ** vartyp 1 store . vartyp 0 C8 
block _ 0 $c ${ int res, argc; 
register uword hn;
argc = 0;
$lbl 10 $cgoto $c !(argc < $r2 )  $e 12 ;
;
hn = hash($r1 + argc);
memb(BlkLoc($r0 ), $r1 + argc, hn, &res);
$cgoto $c !(res == 0)  $e 13 $fail $lbl 13 $lbl 11 argc++;
$goto 10 $lbl 12 $ret d 1 $c $r1 [$r2 - 1]  $e $}  $e 
1 T2 lst abstr nil vartyp 0 
block _ 0 $c ${ C_integer i = 0, sz = Blk(BlkD($r0 , Record)->recdesc, Proc)->nfields; 
C_integer j, k, ismatched, nmatched = 0;
$cgoto $c !($r2 == 0)  $e 14 $fail $lbl 14 i = 0;
$lbl 15 $cgoto $c !(i < $r2 )  $e 17 ${ struct descrip s1;
$cgoto $c !(!cnv_str(&($r1 [i]), &(s1)))  $e 18 err_msg(103, &(s1));
$efail $lbl 18 j = 0;
$lbl 19 $cgoto $c !(j < sz)  $e 21 ${ struct descrip s2 = 
Blk(BlkD($r0 , Record)->recdesc, Proc)->lnames[j];
$cgoto $c !(StrLen(s1) != StrLen(s2))  $e 22 $fail $lbl 22 ismatched = 1;
k = 0;
$lbl 23 $cgoto $c !(k < StrLen(s1))  $e 25 $cgoto $c !(StrLoc(s1)[k] != StrLoc(s2)[k])  $e 26 ismatched = 0;
$goto 25 $lbl 26 $lbl 24 k++;
$goto 23 $lbl 25 $cgoto $c !(ismatched)  $e 27 nmatched++;
$goto 21 $lbl 27 $} $lbl 20 j++;
$goto 19 $lbl 21 $} $lbl 16 i++;
$goto 15 $lbl 17 $cgoto $c !(nmatched == $r2 )  $e 28 $ret d 1 $c $r0  $e $lbl 28 $fail $}  $e 
runerr2 122 0 
$end

membernames	26 1(d)	{0,1} fr_e f 
"membernames(r) - get list of the member vars for class instance r"
0 
0 
if2 is T0 0 
lst abstr nil new T11 1 typ T0 
call 0 s fr_e_ t 0 0 1 $c dptr r  $e $c &($r0 )  $e 
if2 ! is T2 0 
runerr2 107 0 
lst abstr nil new T11 1 typ T0 
call 1 s _r_e_ t 0 0 1 $c dptr r  $e $c &($r0 )  $e 
$end

methodnames	27 2(d,d)	{1,1} _r_e f 
"methodnames(r) - get list of method names for class instance r"
0 
0 
lst lst if1 ! is T2 0 
if1 ! is T0 0 
runerr2 107 0 
abstr nil new T11 1 typ T0 
call 0 s _r_e_ t 0 0 2 $c dptr cooked_names  $e $c &($r1 )  $e $c dptr r  $e $c &($r0 )  $e 
$end

methods	28 1(d)	{1,1} _r_e f 
"methods(r) - get list of methods for class instance r"
1 blkptr b_list nil 
6 blk $c union block *blk;  $e i $c register word i;  $e k $c register word k;  $e n_glbls $c register word n_glbls;  $e n_mthds $c register word n_mthds;  $e bp $c register struct b_lelem *bp;  $e 
lst abstr nil new T11 1 typ T3 
tcase2 0 2 
1 T0 call 0 s _r_e_ t 0 0 8 $c word k  $e $c $m4  $e $c struct b_lelem *bp  $e $c $m7  $e $c dptr p  $e $c &($md1 )  $e $c union block *blk  $e $c $m2  $e $c word n_mthds  $e $c $m6  $e $c word i  $e $c $m3  $e $c word n_glbls  $e $c $m5  $e $c dptr r  $e $c &($r0 )  $e 
1 T2 call 1 s _r_e_ t 0 0 8 $c word k  $e $c $m4  $e $c struct b_lelem *bp  $e $c $m7  $e $c dptr p  $e $c &($md1 )  $e $c union block *blk  $e $c $m2  $e $c word n_mthds  $e $c $m6  $e $c word i  $e $c $m3  $e $c word n_glbls  $e $c $m5  $e $c dptr r  $e $c &($r0 )  $e 
runerr2 107 0 
$end

methods_fromstr	29 1(d)	{1,1} _r_e f 
"methods_fromstr(s) - get list of methods for class instance r"
0 
0 
lst lst if1 ! cnv1 cs 0 
runerr2 103 0 
abstr nil new T11 1 typ T3 
call 0 s _r_e_ t 0 0 1 $c dptr s  $e $c &($rd0 )  $e 
$end

min	0l 1(dv)	{1,1} fr_e f 
"min(x,y,...) - return the minimum of the arguments"
0 
0 
lst abstr nil typ a 
call 0 s fr___ t 0 0 2 $c dptr argv  $e $c $r0  $e $c int argc  $e $c $r1  $e 
$end

mkdir	5y 2(d,d)	{0,1} fr_e f 
"mkdir() - make a new directory."
0 
0 
lst lst lst if1 ! cnv1 cs 0 
runerr2 103 0 
if1 ! is T0 1 
if1 ! is T1 1 
if1 ! is T8 1 
runerr2 170 1 
abstr nil typ T8 
call 0 s fr_e_ t 0 0 2 $c dptr s  $e $c &($rd0 )  $e $c dptr m  $e $c &($r1 )  $e 
$end

move	1i 1(d)	{0,1+} f_se f 
"move(i) - move &pos by i, return substring of &subject spanned. Reverses effects if resumed."
0 
0 
lst lst if1 ! def1 ci 0 $c 1  $e 
runerr2 101 0 
abstr nil typ T0 
call 0 s f_se_ t 0 0 1 $c C_integer i  $e $c $m0  $e 
$end

mutex	1a 1(dv)	{0,0} ___e f 
"an unavailable function"
0 
0 
runerr1 121 
$end

name	10 1(u)	{1,1} _r_e t 
"name(v) - return the name of a variable."
0 
0 
lst lst if1 ! is v 0 
runerr2 111 0 
abstr nil typ T0 
call 0 s _r_e_ t 0 0 1 $c dptr v  $e $c &($m0 )  $e 
$end

numeric	05 1(d)	{0,1} fr__ f 
"numeric(x) - produces an integer or real number resulting from the type conversion of x, but fails if the conversion is not possible."
0 
0 
if2 cnv1 ei 0 
lst abstr nil typ T1 
block _ 0 $c $ret d 1 $c $r0  $e  $e 
if2 cnv1 T10 0 
lst abstr nil typ T10 
block _ 0 $c $ret d 1 $c $r0  $e  $e 
lst abstr nil typ e 
block _ 0 $c $fail  $e 
$end

open	2n 3(d,d,dv)	{0,1} fr_e f 
"open(s1, s2, ...) - open file named s1 with options s2 and attributes given in trailing arguments."
1 desc nil 
0 
lst lst lst if1 ! cnv1 T0 0 
runerr2 103 0 
if1 ! def1 ts 1 $c letr  $e 
runerr2 103 1 
abstr nil typ T13 
call 0 s fr_e_ t 0 0 5 $c dptr filename  $e $c &($m4 )  $e $c int n  $e $c $r3  $e $c dptr attr  $e $c $m2  $e $c dptr spec  $e $c &($r1 )  $e $c dptr fname  $e $c &($r0 )  $e 
$end

oprec	2a 1(d)	{0,1} fr_e t 
"oprec(r) - get the operations record for class instance r"
0 
0 
lst abstr nil typ v 
call 0 s fr_e_ t 0 0 1 $c dptr r  $e $c &($r0 )  $e 
$end

ord	0z 1(d)	{1,1} _r_e f 
"ord(s) - produce integer ordinal (value) of single character."
0 
0 
lst lst if1 ! cnv1 ts 0 
runerr2 103 0 
abstr nil typ T1 
call 0 s _r_e_ t 0 0 1 $c dptr s  $e $c &($r0 )  $e 
$end

pattern_alternate	7u 2(d,d)	{1,1} _r_e f 
""
0 
0 
lst abstr nil typ T14 
call 0 s _r_e_ t 0 0 2 $c dptr RPAT  $e $c &($m1 )  $e $c dptr LPAT  $e $c &($m0 )  $e 
$end

pattern_assign_immediate	7w 2(d,d)	{1,1} _r_e f 
""
0 
0 
lst abstr nil typ T14 
call 0 s _r_e_ t 0 0 2 $c dptr name  $e $c &($r1 )  $e $c dptr PAT  $e $c &($m0 )  $e 
$end

pattern_assign_onmatch	7y 2(d,d)	{1,1} _r_e f 
""
0 
0 
lst abstr nil typ T14 
call 0 s _r_e_ t 0 0 2 $c dptr name  $e $c &($r1 )  $e $c dptr PAT  $e $c &($m0 )  $e 
$end

pattern_boolfunccall	7q 1(d)	{1,1} _r_e f 
""
0 
0 
lst lst if1 ! is T11 0 
runerr2 108 0 
abstr nil typ T14 
call 0 n _r___ t 0 0 1 $c dptr var_list  $e $c &($r0 )  $e 
$end

pattern_boolmethodcall	7r 1(d)	{1,1} _r_e f 
""
0 
0 
lst lst if1 ! is T11 0 
runerr2 108 0 
abstr nil typ T14 
call 0 n _r___ t 0 0 1 $c dptr var_list  $e $c &($r0 )  $e 
$end

pattern_concat	7t 2(d,d)	{1,1} _r_e f 
""
0 
0 
lst abstr nil typ T14 
call 0 s _r_e_ t 0 0 2 $c dptr R  $e $c &($m1 )  $e $c dptr L  $e $c &($m0 )  $e 
$end

pattern_match	78 2(ud,d)	{0,*} f_se f 
""
0 
1 use_trap $c int use_trap = 0;  $e 
lst if2 && is v 0 is T0 1 
lst abstr nil new T5 1 vartyp 0 
block t 0 $c $m3 = 1;  $e 
if2 cnv1 ts 1 
abstr nil typ T0 
runerr2 114 1 
call 0 s f_se_ t 0 0 4 $c dptr psub  $e $c &($m0 )  $e $c int use_trap  $e $c $r3  $e $c dptr pat  $e $c &($m2 )  $e $c dptr dpsub  $e $c &($m1 )  $e 
$end

pattern_setcur	7v 1(d)	{1,1} _r__ f 
""
0 
0 
lst abstr nil typ T14 
call 0 n _r___ t 0 0 1 $c dptr name  $e $c &($r0 )  $e 
$end

pattern_stringfunccall	7o 1(d)	{1,1} _r_e f 
""
0 
0 
lst lst if1 ! is T11 0 
runerr2 108 0 
abstr nil typ T14 
call 0 n _r___ t 0 0 1 $c dptr var_list  $e $c &($r0 )  $e 
$end

pattern_stringmethodcall	7p 1(d)	{1,1} _r_e f 
""
0 
0 
lst lst if1 ! is T11 0 
runerr2 108 0 
abstr nil typ T14 
call 0 n _r___ t 0 0 1 $c dptr var_list  $e $c &($r0 )  $e 
$end

pattern_unevalvar	7s 1(d)	{1,1} _r__ f 
""
0 
0 
lst abstr nil typ T14 
call 0 n _r___ t 0 0 1 $c dptr name  $e $c &($r0 )  $e 
$end

pindex_image	0w 2(d,d)	{1,1} _r_e t 
""
0 
0 
lst lst if1 ! cnv1 ci 1 
runerr2 101 1 
abstr nil typ T0 
call 0 s _r_e_ t 0 0 2 $c C_integer i  $e $c $r1  $e $c dptr x  $e $c &($m0 )  $e 
$end

pipe	65 0()	{0,1} fr_e f 
"pipe() - create a pipe."
0 
0 
lst abstr nil new T11 1 typ T13 
call 0 s fr_e_ t 0 0 0 
$end

pop	22 2(d,d)	{0,1} fr_e t 
"pop(x) - pop an element from the left end of list x."
0 
0 
lst if1 ! def1 ci 1 $c 1L  $e 
runerr2 101 1 
tcase2 0 2 
1 T13 lst abstr nil typ T0 
call 0 s fr_e_ t 0 0 1 $c dptr x  $e $c &($r0 )  $e 
1 T11 lst abstr nil store . vartyp 0 C3 
call 1 s fr___ t 0 0 2 $c dptr x  $e $c &($m0 )  $e $c C_integer i  $e $c $r1  $e 
runerr2 108 0 
$end

pos	1j 1(d)	{0,1} fr_e f 
"pos(i) - test if &pos is at position i in &subject."
0 
0 
lst lst if1 ! cnv1 ci 0 
runerr2 101 0 
abstr nil typ T1 
call 0 s fr___ t 0 0 1 $c C_integer i  $e $c $m0  $e 
$end

proc	06 2(d,d)	{0,1} fr_e f 
"proc(x,i) - convert x to a procedure if possible; use i to resolve ambiguous string names."
0 
0 
if2 is T3 0 
lst abstr nil typ T3 
block _ 0 $c $ret d 1 $c $r0  $e  $e 
if2 cnv1 ts 0 
lst lst lst if1 ! def1 ci 1 $c 1  $e 
runerr2 101 1 
block t 0 $c $cgoto $c !($r1 < 0 || $r1 > 3)  $e 0 irunerr(205, $r1 );
$efail $lbl 0  $e 
abstr nil typ T3 
block _ 0 $c ${ struct b_proc *prc;
$cgoto $c $r1 == 0  $e 1 prc = strprc(&$m0 , $r1 );
$goto 2 $lbl 1 prc = bi_strprc(&$m0 , 0);
$lbl 2 $cgoto $c prc == NULL  $e 3 $ret T3 1 $c prc  $e $goto 4 $lbl 3 $fail $lbl 4 $}  $e 
lst abstr nil typ e 
block _ 0 $c $fail  $e 
$end

pull	2d 2(d,d)	{0,1} fr_e t 
"pull(L,n) - pull an element from end of list L."
0 
0 
lst lst lst if1 ! def1 ci 1 $c 1L  $e 
runerr2 101 1 
if1 ! is T11 0 
runerr2 108 0 
abstr nil store . vartyp 0 C3 
call 0 s fr___ t 0 0 2 $c dptr x  $e $c &($m0 )  $e $c C_integer n  $e $c $r1  $e 
$end

push	2e 2(d,dv)	{1,1} fr_e f 
"push(L, x1, ..., xN) - push x onto beginning of list L."
0 
0 
lst lst if1 ! is T11 0 
runerr2 108 0 
abstr = . vartyp 0 C3 vartyp 1 vartyp 0 
call 0 s fr_e_ t 0 0 3 $c dptr vals  $e $c $r1  $e $c int n  $e $c $r2  $e $c dptr x  $e $c &($m0 )  $e 
$end

put	2f 2(d,dv)	{1,1} fr_e f 
"put(L, x1, ..., xN) - put elements onto end of list L."
0 
0 
lst lst if1 ! is T11 0 
runerr2 108 0 
abstr = . vartyp 0 C3 vartyp 1 vartyp 0 
call 0 s fr_e_ t 0 0 3 $c dptr vals  $e $c $r1  $e $c int n  $e $c $r2  $e $c dptr x  $e $c &($m0 )  $e 
$end

read	2o 1(d)	{0,1} fr_e f 
"read(f) - read line on file f."
0 
0 
lst lst if2 is T8 0 
block t 0 $c $m0 .dword = D_File;
BlkLoc($r0 ) = (union block *)&k_input;  $e 
if1 ! is T13 0 
runerr2 105 0 
abstr nil typ T0 
call 0 s fr_e_ t 0 0 1 $c dptr f  $e $c &($r0 )  $e 
$end

readlink	5r 1(d)	{0,1} fr_e t 
"readlink() - read a symbolic link."
0 
0 
lst lst if1 ! cnv1 cs 0 
runerr2 103 0 
abstr nil typ T0 
call 0 s fr_e_ t 0 0 1 $c dptr s  $e $c &($rd0 )  $e 
$end

reads	2p 2(d,d)	{0,1} fr_e f 
"reads(f,i) - read i characters on file f."
0 
0 
lst lst lst if2 is T8 0 
block t 0 $c $m0 .dword = D_File;
BlkLoc($r0 ) = (union block *)&k_input;  $e 
if1 ! is T13 0 
runerr2 105 0 
if1 ! def1 ci 1 $c 1L  $e 
runerr2 101 1 
abstr nil typ T0 
call 0 s fr_e_ t 0 0 2 $c C_integer i  $e $c $m1  $e $c dptr f  $e $c &($r0 )  $e 
$end

ready	72 2(d,d)	{0,1} fr_e f 
"ready() - low level non-blocking read with no buffering."
0 
0 
lst lst lst if1 ! def1 ci 1 $c 0  $e 
runerr2 101 1 
if2 is T8 0 
block t 0 $c $m0 .dword = D_File;
BlkLoc($r0 ) = (union block *)&k_input;  $e 
if1 ! is T13 0 
runerr2 105 0 
abstr nil typ T0 
call 0 s fr_e_ t 0 0 2 $c C_integer i  $e $c $m1  $e $c dptr f  $e $c &($r0 )  $e 
$end

real	03 1(d)	{0,1} fr__ f 
"real(x) - produces a value of type real resulting from the conversion of x, but fails if the conversion is not possible."
0 
0 
if2 cnv1 T10 0 
lst abstr nil typ T10 
block _ 0 $c $ret d 1 $c $r0  $e  $e 
lst abstr nil typ e 
block _ 0 $c $fail  $e 
$end

receive	6r 1(d)	{0,1} fr_e t 
"receive() - receive a UDP datagram."
0 
0 
lst lst if1 ! is T13 0 
runerr2 105 0 
abstr nil typ T2 
call 0 s fr_e_ t 0 0 1 $c dptr f  $e $c &($r0 )  $e 
$end

remove	2q 1(d)	{0,1} fr_e f 
"remove(s) - remove the file named s."
0 
0 
lst lst if1 ! cnv1 cs 0 
runerr2 103 0 
abstr nil typ T8 
block _ 0 $c CURTSTATE();
$cgoto $c !(remove($r0 ) != 0)  $e 0 IntVal(amperErrno) = 0;
$cgoto $c !(rmdir($r0 ) == 0)  $e 1 $ret d 1 $c nulldesc  $e $lbl 1 set_syserrortext(errno);
$fail $lbl 0 $ret d 1 $c nulldesc  $e  $e 
$end

rename	2r 2(d,d)	{0,1} fr_e f 
"rename(s1,s2) - rename the file named s1 to have the name s2."
0 
0 
lst lst lst if1 ! cnv1 cs 0 
runerr2 103 0 
if1 ! cnv1 cs 1 
runerr2 103 1 
abstr nil typ T8 
call 0 s fr___ t 0 0 2 $c dptr s2  $e $c &($rd1 )  $e $c dptr s1  $e $c &($rd0 )  $e 
$end

repl	1q 2(d,d)	{1,1} _r_e t 
"repl(s,i) - concatenate i copies of string s."
0 
0 
lst lst if1 ! cnv1 ci 1 
runerr2 101 1 
block t 0 $c $cgoto $c !($r1 < 0)  $e 0 irunerr(205, $r1 );
$efail $lbl 0  $e 
if2 is T11 0 
lst abstr nil vartyp 0 
call 0 s _r_e_ t 0 0 2 $c C_integer n  $e $c $r1  $e $c dptr s  $e $c &($m0 )  $e 
if2 cnv1 T0 0 
lst abstr nil typ T0 
call 1 s _r_e_ t 0 0 2 $c C_integer n  $e $c $m1  $e $c dptr s  $e $c &($r0 )  $e 
runerr2 103 0 
$end

reverse	1r 1(d)	{1,1} _r_e t 
"reverse(s) - reverse string s."
0 
0 
if2 is T11 0 
lst abstr nil vartyp 0 
call 0 n _r___ t 0 0 1 $c dptr x  $e $c &($m0 )  $e 
lst lst if1 ! cnv1 T0 0 
runerr2 103 0 
abstr nil typ T0 
call 1 s _r_e_ t 0 0 1 $c dptr x  $e $c &($r0 )  $e 
$end

right	1s 3(d,d,d)	{1,1} _r_e f 
"right(s1,i,s2) - pad s1 on left with s2 to length i."
0 
0 
lst lst lst lst if1 ! cnv1 T0 0 
runerr2 103 0 
if1 ! def1 ci 1 $c 1  $e 
runerr2 101 1 
if1 ! def1 ts 2 $c blank  $e 
runerr2 103 2 
abstr nil typ T0 
call 0 s _r_e_ t 0 0 3 $c dptr s1  $e $c &($r0 )  $e $c dptr s2  $e $c &($m2 )  $e $c C_integer n  $e $c $r1  $e 
$end

rmdir	5x 1(d)	{0,1} fr_e f 
"rmdir() - remove an empty directory."
0 
0 
lst lst if1 ! cnv1 cs 0 
runerr2 103 0 
abstr nil typ T8 
block _ 0 $c CURTSTATE();
IntVal(amperErrno) = 0;
$cgoto $c !(rmdir($r0 ) != 0)  $e 0 IntVal(amperErrno) = errno;
$fail $lbl 0 $ret d 1 $c nulldesc  $e  $e 
$end

rtod	0h 1(d)	{1,1} _r_e f 
"rtod(r) - convert x from radians to degrees."
0 
0 
lst lst if1 ! cnv1 cd 0 
runerr2 102 0 
abstr nil typ T10 
block _ 0 $c ${ double y;
;
errno = 0;
y = (($r0 ) * 180 / Pi);
;
$ret cd 1 $c y  $e $}  $e 
$end

runerr	11 2(d,dv)	{} ___e f 
"runerr(i,x) - produce runtime error i with value x."
0 
0 
lst if1 ! cnv1 ci 0 
runerr2 101 0 
call 0 n ___e_ f 0 0 3 $c dptr x  $e $c $r1  $e $c int n  $e $c $r2  $e $c C_integer i  $e $c $r0  $e 
$end

seek	2s 2(d,d)	{0,1} fr_e f 
"seek(f,i) - seek to offset i in file f. [[ What about seek error ? ]] "
0 
0 
lst lst lst if1 ! is T13 0 
runerr2 105 0 
if1 ! def1 ci 1 $c 1L  $e 
runerr1 0 
abstr nil typ T13 
call 0 s fr___ t 0 0 2 $c C_integer o  $e $c $r1  $e $c dptr f  $e $c &($r0 )  $e 
$end

select	6t 1(dv)	{0,1} fr_e f 
"select() - wait for i/o to be available on files."
0 
0 
lst abstr nil new T11 1 typ T13 
call 0 s fr_e_ t 0 0 2 $c dptr files  $e $c $r0  $e $c int nargs  $e $c $r1  $e 
$end

send	6q 4(d,d,d,d)	{0,1} fr_e f 
"send() - send a UDP datagram."
0 
0 
lst lst lst if1 ! cnv1 cs 0 
runerr2 103 0 
if1 ! cnv1 T0 1 
runerr2 103 1 
abstr nil typ T8 
call 0 s fr_e_ t 0 0 3 $c dptr msg  $e $c &($r1 )  $e $c dptr addr  $e $c &($rd0 )  $e $c dptr fam  $e $c &($r3 )  $e 
$end

seq	12 2(d,d)	{1,*} __se f 
"seq(i, j) - generate i, i+j, i+2*j, ... ."
0 
0 
lst lst lst if1 ! def1 ci 0 $c 1  $e 
runerr2 101 0 
if1 ! def1 ci 1 $c 1  $e 
runerr2 101 1 
abstr nil typ T1 
call 0 s __se_ t 0 0 2 $c C_integer from  $e $c $m0  $e $c C_integer by  $e $c $r1  $e 
$end

serial	13 1(d)	{0,1} fr__ f 
"serial(x) - return serial number of structure."
0 
0 
lst abstr nil typ T1 
tcase2 0 7 
1 T13 block _ 0 $c $cgoto $c BlkD($r0 , File)->status & Fs_Window  $e 1 $fail $goto 2 $lbl 1 ${ wsp ws = BlkD($r0 , File)->fd.wb->window;
$ret ci 1 $c ws->serial  $e $} $lbl 2  $e 
1 T8 block _ 0 $c CURTSTATE();
$ret ci 1 $c BlkD(k_current, Coexpr)->id  $e  $e 
1 T4 block _ 0 $c $ret ci 1 $c BlkD($r0 , Coexpr)->id  $e  $e 
1 T2 block _ 0 $c $ret ci 1 $c BlkD($r0 , Record)->id  $e  $e 
1 T12 block _ 0 $c $ret ci 1 $c BlkD($r0 , Table)->id  $e  $e 
1 T15 block _ 0 $c $ret ci 1 $c BlkD($r0 , Set)->id  $e  $e 
1 T11 block _ 0 $c $ret ci 1 $c BlkD($r0 , List)->id  $e  $e 
block _ 0 $c $fail  $e 
$end

set	2g 1(dv)	{1,1} _r_e f 
"set(L) - create a set with members in list L.  The members are linked into hash chains which are arranged in increasing order by hash number."
0 
0 
lcase 1 
0 lst abstr nil new T15 1 typ e 
block _ 0 $c ${ register union block *ps;
ps = hmake(T_Set, (word)0, (word)0);
$cgoto $c !(ps == NULL)  $e 0 err_msg(0, NULL);
$efail $lbl 0 ;
$ret T15 1 $c ps  $e $}  $e 
lst abstr nil new T15 1 vartyp 0 
call 0 s _r_e_ t 0 0 2 $c int n  $e $c $r1  $e $c dptr x  $e $c $m0  $e 
$end

setenv	74 2(d,d)	{0,1} fr_e f 
"setenv() - set an environment variable."
0 
0 
lst lst lst if1 ! cnv1 cs 0 
runerr2 103 0 
if1 ! cnv1 cs 1 
runerr2 103 1 
abstr nil typ T8 
block _ 0 $c $cgoto $c !(setenv($r0 , $r1 , 1) < 0)  $e 0 $fail $lbl 0 $ret d 1 $c nulldesc  $e  $e 
$end

setgid	6e 1(d)	{0,1} fr_e f 
"setgid() - set the real and/or effective group identity."
0 
0 
lst lst if1 ! cnv1 ci 0 
runerr2 101 0 
abstr nil typ T8 
block _ 0 $c CURTSTATE();
IntVal(amperErrno) = 0;
$cgoto $c !(setgid($r0 ) != 0)  $e 0 IntVal(amperErrno) = errno;
$fail $lbl 0 $ret d 1 $c nulldesc  $e  $e 
$end

setgrent	6z 0()	{0,1} _r__ f 
"setgrent() - reset the group file."
0 
0 
lst abstr nil typ T8 
call 0 n _r___ t 0 0 0 
$end

sethostent	70 1(d)	{0,1} _r_e f 
"sethostent() - reset host processing."
0 
0 
lst lst if1 ! def1 ci 0 $c 1  $e 
runerr2 101 0 
abstr nil typ T8 
call 0 n _r___ t 0 0 1 $c C_integer so  $e $c $r0  $e 
$end

setpgrp	6g 0()	{0,1} fr__ f 
"setpgrp() - set the process group."
0 
0 
lst abstr nil typ T8 
block _ 0 $c CURTSTATE();
IntVal(amperErrno) = 0;
$cgoto $c !(Setpgrp() != 0)  $e 0 IntVal(amperErrno) = errno;
$fail $lbl 0 $ret d 1 $c nulldesc  $e  $e 
$end

setpwent	6y 0()	{0,1} _r__ f 
"setpwent() - reset the password file."
0 
0 
lst abstr nil typ T8 
call 0 n _r___ t 0 0 0 
$end

setservent	71 1(d)	{0,1} _r_e f 
"setservent() - reset network service entry processing."
0 
0 
lst lst if1 ! def1 ci 0 $c 1  $e 
runerr2 101 0 
abstr nil typ T8 
call 0 n _r___ t 0 0 1 $c C_integer so  $e $c $r0  $e 
$end

setuid	6d 1(d)	{0,1} fr_e f 
"setuid() - set the real and/or effective user identity."
0 
0 
lst lst if1 ! cnv1 ci 0 
runerr2 101 0 
abstr nil typ T8 
block _ 0 $c CURTSTATE();
IntVal(amperErrno) = 0;
$cgoto $c !(setuid($r0 ) != 0)  $e 0 IntVal(amperErrno) = errno;
$fail $lbl 0 $ret d 1 $c nulldesc  $e  $e 
$end

signal	1g 1(dv)	{0,0} ___e f 
"an unavailable function"
0 
0 
runerr1 121 
$end

sin	08 1(d)	{1,1} _r_e f 
"sin(r), x in radians."
0 
0 
lst lst if1 ! cnv1 cd 0 
runerr2 102 0 
abstr nil typ T10 
block _ 0 $c ${ double y;
;
errno = 0;
y = sin($r0 );
;
$ret cd 1 $c y  $e $}  $e 
$end

sort	14 2(d,d)	{1,1} _r_e t 
"sort(x,i) - sort structure x by method i (for tables)"
0 
0 
tcase2 0 4 
1 T12 lst lst abstr nil new T11 1 ++ new T11 1 store ++ . vartyp 0 C4 . vartyp 0 C5 store ++ . vartyp 0 C4 . vartyp 0 C5 
if1 ! def1 ci 1 $c 1  $e 
runerr2 101 1 
call 0 s _r_e_ t 0 0 2 $c dptr t  $e $c &($r0 )  $e $c C_integer i  $e $c $r1  $e 
1 T15 lst abstr nil new T11 1 store . vartyp 0 C8 
call 1 n _r___ t 0 0 1 $c dptr t  $e $c &($m0 )  $e 
1 T2 lst abstr nil new T11 1 store . vartyp 0 f 
call 2 s _r_e_ t 0 0 1 $c dptr t  $e $c &($r0 )  $e 
1 T11 lst abstr nil vartyp 0 
call 3 s _r_e_ t 0 0 1 $c dptr t  $e $c &($m0 )  $e 
runerr2 115 0 
$end

sortf	15 2(d,d)	{1,1} _r_e t 
"sortf(x,i) - sort list or set x on field i of each member"
0 
0 
tcase2 0 3 
1 T15 lst lst abstr nil new T11 1 store . vartyp 0 C8 
if1 ! def1 ci 1 $c 1  $e 
runerr2 101 1 
call 0 s _r_e_ t 0 0 2 $c dptr t  $e $c &($r0 )  $e $c C_integer i  $e $c $r1  $e 
1 T2 lst lst abstr nil new T11 1 typ a 
if1 ! def1 ci 1 $c 1  $e 
runerr2 101 1 
call 1 s _r_e_ t 0 0 2 $c dptr t  $e $c &($r0 )  $e $c C_integer i  $e $c $r1  $e 
1 T11 lst lst abstr nil vartyp 0 
if1 ! def1 ci 1 $c 1  $e 
runerr2 101 1 
call 2 s _r_e_ t 0 0 2 $c dptr t  $e $c &($m0 )  $e $c C_integer i  $e $c $r1  $e 
runerr2 125 0 
$end

spawn	1f 1(dv)	{0,0} ___e f 
"an unavailable function"
0 
0 
runerr1 121 
$end

sql	5j 2(d,d)	{} ___e f 
"an unavailable function"
0 
0 
runerr1 121 
$end

sqrt	0f 1(d)	{1,1} _r_e f 
"sqrt(r) - square root of x."
0 
0 
lst lst if1 ! cnv1 cd 0 
runerr2 102 0 
abstr nil typ T10 
block _ 0 $c ${ double y;
$cgoto $c !($r0 < 0)  $e 0 drunerr(205, $r0 );
$efail $lbl 0 errno = 0;
y = sqrt($r0 );
$cgoto $c !(errno == EDOM)  $e 1 err_msg(205, NULL);
$efail $lbl 1 $ret cd 1 $c y  $e $}  $e 
$end

stat	6p 1(d)	{0,1} fr_e t 
"stat() - get file status."
0 
0 
tcase2 0 2 
1 T13 lst abstr nil typ T2 
call 0 s fr_e_ t 0 0 1 $c dptr f  $e $c &($r0 )  $e 
1 T0 lst abstr nil typ T2 
call 1 s fr_e_ t 0 0 1 $c dptr f  $e $c &($r0 )  $e 
runerr2 109 0 
$end

stop	2v 1(dv)	{} ___e f 
"stop(a,b,...) - write arguments (starting on error output) and stop."
0 
2 f $c union f f;  $e status $c word status = 
k_errout.status;  $e 
lst abstr nil typ e 
lcase 1 
0 lst block t 0 $c $cgoto $c (k_errout.status & Fs_Write) == 0  $e 0 $m2 .fp = k_errout.fd.fp;
$goto 1 $lbl 0 MUTEX_UNLOCKID(fblk->mutexid);err_msg(
213, NULL);
$efail $lbl 1  $e 
call 0 n ___e_ f 0 0 2 $c union f (*f)  $e $c &($r2 )  $e $c word status  $e $c $r3  $e 
lst if1 ! is T13 [ 0 0 
block t 0 $c $cgoto $c (k_errout.status & Fs_Write) == 0  $e 2 $m2 .fp = k_errout.fd.fp;
$goto 3 $lbl 2 MUTEX_UNLOCKID(fblk->mutexid);err_msg(
213, NULL);
$efail $lbl 3  $e 
call 1 n ___e_ f 0 0 4 $c union f (*f)  $e $c &($m2 )  $e $c word status  $e $c $m3  $e $c dptr x  $e $c $r0  $e $c int nargs  $e $c $r1  $e 
$end

string	04 1(dv)	{0,1} fr_e f 
"string(x) - produces a value of type string resulting from the conversion of x, but fails if the conversion is not possible."
0 
0 
lst abstr nil ++ typ T0 typ e 
call 0 s fr_e_ t 0 0 2 $c dptr x  $e $c $m0  $e $c int n  $e $c $r1  $e 
$end

symlink	5q 2(d,d)	{0,1} fr_e f 
"symlink() - create a symlink to a file."
0 
0 
lst lst lst if1 ! cnv1 cs 0 
runerr2 103 0 
if1 ! cnv1 cs 1 
runerr2 103 1 
abstr nil typ T8 
block _ 0 $c CURTSTATE();
IntVal(amperErrno) = 0;
$cgoto $c !(symlink($r0 , $r1 ) != 0)  $e 0 IntVal(amperErrno) = errno;
$fail $lbl 0 $ret d 1 $c nulldesc  $e  $e 
$end

sys_errstr	5m 1(d)	{0,1} fr_e t 
"sys_errstr() - get the error string corresponding to an &errno value."
0 
0 
lst abstr nil typ T0 
block _ 0 $c ${ C_integer ern;
CURTSTATE();
$cgoto $c !(!def_c_int(&($r0 ), IntVal(amperErrno), &(ern)))  $e 0 err_msg(101, &($r0 ));
$efail $lbl 0 $cgoto $c (StrLoc($rr ) = alc_strerror(ern)) != 0  $e 1 $cgoto $c !(errno == EINVAL)  $e 2 $fail $lbl 2 err_msg(0, NULL);
$efail $goto 3 $lbl 1 StrLen($rr ) = strlen(StrLoc($rr ));
$lbl 3 $ret rn 0 $}  $e 
$end

system	2t 5(d,d,d,d,d)	{0,1} fr_e f 
"system() - create a new process, optionally mapping its stdin/stdout/stderr."
0 
0 
lst lst lst lst lst lst if1 ! is T13 1 
if1 ! is T0 1 
if1 ! is T8 1 
runerr2 105 1 
if1 ! is T13 2 
if1 ! is T0 2 
if1 ! is T8 2 
runerr2 105 2 
if1 ! is T13 3 
if1 ! is T0 3 
if1 ! is T8 3 
runerr2 105 3 
if1 ! is T11 0 
if1 ! is T0 0 
runerr2 110 0 
if1 ! is T0 4 
if1 ! is T1 4 
if1 ! is T13 4 
if1 ! is T8 4 
runerr2 170 4 
abstr nil ++ typ T8 typ T1 
call 0 s fr_e_ t 0 0 5 $c dptr d_stdin  $e $c &($m1 )  $e $c dptr d_stderr  $e $c &($m3 )  $e $c dptr d_stdout  $e $c &($m2 )  $e $c dptr argv  $e $c &($r0 )  $e $c dptr mode  $e $c &($r4 )  $e 
$end

syswrite	73 2(d,d)	{0,1} fr_e f 
"syswrite() - low level write with no buffering."
0 
0 
lst lst lst if1 ! cnv2 T0 1 $c $m1  $e 
runerr2 103 1 
if2 is T8 0 
block t 0 $c $m0 .dword = D_File;
BlkLoc($r0 ) = (union block *)&k_output;  $e 
if1 ! is T13 0 
runerr2 105 0 
abstr nil typ T1 
call 0 s fr_e_ t 0 0 2 $c dptr s  $e $c &($r1 )  $e $c dptr f  $e $c &($r0 )  $e 
$end

tab	1k 1(d)	{0,1+} f_se f 
"tab(i) - set &pos to i, return substring of &subject spanned.Reverses effects if resumed."
0 
0 
lst lst if1 ! def1 ci 0 $c 0  $e 
runerr2 101 0 
abstr nil typ T0 
call 0 s f_se_ t 0 0 1 $c C_integer i  $e $c $m0  $e 
$end

table	2h 1(dv)	{1,1} _r_e f 
"table(k, v, ..., x) - create a table with default value x."
0 
0 
lst abstr nil new T12 3 typ e typ e vartyp 0 
block _ 1 blkptr $c $t0 .vword.bptr = hmake(T_Table, (word)0, (word)$r1 );
$cgoto $c !($t0 .vword.bptr == NULL)  $e 0 err_msg(0, NULL);
$efail $lbl 0 $cgoto $c !($r1 > 1)  $e 1 $cgoto $c !(c_inserttable(&$t0 .vword.bptr, $r1 - $r1 % 2, $r0 ) == -1)  $e 2 err_msg(0, NULL);
$efail $lbl 2 $lbl 1 $cgoto $c $r1 % 2  $e 3 $t0 .vword.bptr->Table.defvalue = nulldesc;
$goto 4 $lbl 3 $t0 .vword.bptr->Table.defvalue = $r0 [$r1 - 1];
$lbl 4 ;
$ret T12 1 $c $t0 .vword.bptr  $e  $e 
$end

tan	0a 1(d)	{1,1} _r_e f 
"tan(r), x in radians."
0 
0 
lst lst if1 ! cnv1 cd 0 
runerr2 102 0 
abstr nil typ T10 
block _ 0 $c ${ double y;
;
errno = 0;
y = tan($r0 );
$cgoto $c !(errno == ERANGE)  $e 0 err_msg(204, NULL);
$efail $lbl 0 $ret cd 1 $c y  $e $}  $e 
$end

trap	5t 2(d,d)	{0,1} fr_e f 
"trap() - trap a signal."
0 
0 
lst lst if1 ! is T0 0 
if1 ! is T1 0 
runerr2 170 0 
abstr nil typ T3 
call 0 s fr_e_ t 0 0 2 $c dptr handler  $e $c &($r1 )  $e $c dptr nsignal  $e $c &($r0 )  $e 
$end

trim	1t 3(d,d,d)	{1,1} _r_e f 
"trim(s,c) - trim trailing characters in c from s."
0 
0 
lst lst lst lst if1 ! cnv1 T0 0 
runerr2 103 0 
if1 ! def1 tc 1 $c blankcs  $e 
runerr2 104 1 
if1 ! def1 ci 2 $c -1  $e 
runerr2 101 2 
abstr nil typ T0 
call 0 n _r___ t 0 0 3 $c dptr c  $e $c &($r1 )  $e $c C_integer ends  $e $c $r2  $e $c dptr s  $e $c &($r0 )  $e 
$end

truncate	5z 2(d,d)	{0,1} fr_e f 
"truncate() - truncate a file at a certain position."
0 
0 
lst if1 ! cnv1 ci 1 
runerr2 101 1 
tcase2 0 2 
1 T13 lst abstr nil typ T8 
call 0 s fr_e_ t 0 0 2 $c C_integer l  $e $c $r1  $e $c dptr f  $e $c &($r0 )  $e 
1 T0 lst abstr nil typ T8 
call 1 s fr___ t 0 0 2 $c C_integer l  $e $c $r1  $e $c dptr f  $e $c &($r0 )  $e 
runerr2 109 0 
$end

trylock	1c 1(dv)	{0,0} ___e f 
"an unavailable function"
0 
0 
runerr1 121 
$end

type	16 1(d)	{1,1} _r_e f 
"type(x) - return type of x as a string."
0 
0 
lst abstr nil typ T0 
tcase2 0 13 
1 T14 block _ 0 $c $ret cs 1 $c "pattern"  $e  $e 
1 T4 block _ 0 $c $ret cs 1 $c "co-expression"  $e  $e 
1 T2 block _ 0 $c $ret d 1 $c Blk(BlkD($r0 , Record)->recdesc, Proc)->recname  $e  $e 
1 T15 block _ 0 $c $ret cs 1 $c "set"  $e  $e 
1 T12 block _ 0 $c $ret cs 1 $c "table"  $e  $e 
1 T11 block _ 0 $c $ret cs 1 $c "list"  $e  $e 
1 T3 block _ 0 $c $ret cs 1 $c "procedure"  $e  $e 
1 T13 block _ 0 $c $cgoto $c !(BlkD($r0 , File)->status & Fs_Window)  $e 0 $ret cs 1 $c "window"  $e $lbl 0 $ret cs 1 $c "file"  $e  $e 
1 T9 block _ 0 $c $ret cs 1 $c "cset"  $e  $e 
1 T10 block _ 0 $c $ret cs 1 $c "real"  $e  $e 
1 T1 block _ 0 $c $ret cs 1 $c "integer"  $e  $e 
1 T8 block _ 0 $c $ret cs 1 $c "null"  $e  $e 
1 T0 block _ 0 $c $ret cs 1 $c "string"  $e  $e 
block _ 0 $c err_msg(123, &($r0 ));
$efail  $e 
$end

umask	6i 1(d)	{0,1} _r_e t 
"umask() - set the umask and return the old value."
1 str nil 
1 m $c C_integer m;  $e 
if2 cnv2 ci 0 $c $m2  $e 
lst abstr nil typ T1 
block _ 0 $c $ret ci 1 $c umask($r2 )  $e  $e 
if2 cnv2 cs 0 $c $m1  $e 
lst abstr nil typ T0 
call 0 s _r_e_ t 0 0 2 $c dptr mask  $e $c &($r0 )  $e $c dptr perm  $e $c &($rd1 )  $e 
if2 is T8 0 
lst abstr nil typ T0 
call 1 s _r_e_ t 0 0 0 
runerr2 170 0 
$end

unlock	1d 1(dv)	{0,0} ___e f 
"an unavailable function"
0 
0 
runerr1 121 
$end

upto	1z 4(d,d,d,d)	{0,*} f_se f 
"upto(c,s,i1,i2) - generates the sequence of integer positions in s up to a character in c in s[i2:i2], but fails if there is no such position."
0 
2 cnv_i $c C_integer cnv_i;  $e cnv_j $c C_integer cnv_j;  $e 
lst lst lst lst lst abstr nil typ T1 
if2 is T8 1 
lst block t 0 $c CURTSTATE();
$m1 = k_subject;  $e 
if1 is T8 2 
block t 0 $c CURTSTATE();
$m4 = k_pos;  $e 
lst if1 ! cnv1 T0 1 
runerr2 103 1 
if1 is T8 2 
block t 0 $c $m4 = 1;  $e 
if1 ! is T8 2 
if2 cnv2 ci 2 $c $m4  $e 
block t 0 $c $cgoto $c !(($m4 = cvpos($r4 , StrLen($r1 ))) == CvtFail)  $e 0 $fail $lbl 0  $e 
runerr2 101 2 
if2 is T8 3 
block t 0 $c $m5 = StrLen($r1 ) + 1;  $e 
if2 cnv2 ci 3 $c $m5  $e 
block t 0 $c $cgoto $c !(($m5 = cvpos($r5 , StrLen($r1 ))) == CvtFail)  $e 1 $fail $lbl 1 $cgoto $c !($r4 > $r5 )  $e 2 ${ register C_integer tmp;
tmp = $r4 ;
$m4 = $r5 ;
$m5 = tmp;
$} $lbl 2  $e 
runerr2 101 3 
if1 ! cnv1 tc 0 
runerr2 104 0 
call 0 s f_s__ t 0 0 4 $c dptr c  $e $c &($r0 )  $e $c dptr s  $e $c &($r1 )  $e $c C_integer cnv_j  $e $c $r5  $e $c C_integer cnv_i  $e $c $m4  $e 
$end

utime	62 3(d,d,d)	{0,1} fr_e f 
"utime() - set access and/or modification times on a file."
0 
0 
lst lst lst lst if1 ! cnv1 cs 0 
runerr2 103 0 
if1 ! cnv1 ci 2 
runerr2 101 2 
if1 ! cnv1 ci 1 
runerr2 101 1 
abstr nil typ T8 
call 0 s fr___ t 0 0 3 $c dptr f  $e $c &($rd0 )  $e $c C_integer mtime  $e $c $r2  $e $c C_integer atime  $e $c $r1  $e 
$end

variable	17 1(d)	{0,1} fr_e t 
"variable(s) - find the variable with name s and return a variable descriptor which points to its value."
0 
0 
lst lst if1 ! cnv1 cs 0 
runerr2 103 0 
abstr nil typ v 
call 0 s fr___ t 0 0 1 $c dptr s  $e $c &($rd0 )  $e 
$end

wait	6j 2(d,d)	{0,1} fr_e t 
"wait() - wait for process (or co-exp thread) to terminate or stop.the return value is `status' from the wait(2) manpage.OR: - wait on condition variable pid."
0 
0 
lst lst lst if1 ! def1 ci 0 $c -1  $e 
runerr2 101 0 
if1 ! def1 cs 1 $c ""  $e 
runerr2 103 1 
abstr nil typ T0 
call 0 s fr_e_ t 0 0 2 $c dptr options  $e $c &($rd1 )  $e $c C_integer pid  $e $c $r0  $e 
$end

where	2u 1(d)	{0,1} fr_e f 
"where(f) - return current offset position in file f."
0 
0 
lst lst if1 ! is T13 0 
runerr2 105 0 
abstr nil typ T1 
call 0 s fr___ t 0 0 1 $c dptr f  $e $c &($r0 )  $e 
$end

write	2w 1(dv)	{1,1} fr_e f 
"write(a,b,...) - write arguments."
0 
2 f $c union f f;  $e status $c word status = 
k_output.status;  $e 
lcase 1 
0 lst lst abstr nil typ T8 
block t 0 $c $cgoto $c (k_output.status & Fs_Write) == 0  $e 0 $m2 .fp = k_output.fd.fp;
$goto 1 $lbl 0 MUTEX_UNLOCKID(fblk->mutexid);err_msg(
213, NULL);
$efail $lbl 1  $e 
call 0 s fr_e_ t 0 0 2 $c union f (*f)  $e $c &($r2 )  $e $c word status  $e $c $r3  $e 
lst lst abstr nil vartyp 0 
if1 ! is T13 [ 0 0 
block t 0 $c $cgoto $c (k_output.status & Fs_Write) == 0  $e 2 $m2 .fp = k_output.fd.fp;
$goto 3 $lbl 2 MUTEX_UNLOCKID(fblk->mutexid);err_msg(
213, NULL);
$efail $lbl 3  $e 
call 1 s fr_e_ t 0 0 4 $c union f (*f)  $e $c &($m2 )  $e $c word status  $e $c $m3  $e $c dptr x  $e $c $r0  $e $c int nargs  $e $c $r1  $e 
$end

writes	2x 1(dv)	{1,1} fr_e f 
"writes(a,b,...) - write arguments without newline terminator."
0 
2 f $c union f f;  $e status $c word status = 
k_output.status;  $e 
lcase 1 
0 lst lst abstr nil typ T8 
block t 0 $c $cgoto $c (k_output.status & Fs_Write) == 0  $e 0 $m2 .fp = k_output.fd.fp;
$goto 1 $lbl 0 MUTEX_UNLOCKID(fblk->mutexid);err_msg(
213, NULL);
$efail $lbl 1  $e 
call 0 s _r_e_ t 0 0 2 $c union f (*f)  $e $c &($r2 )  $e $c word status  $e $c $r3  $e 
lst lst abstr nil vartyp 0 
if1 ! is T13 [ 0 0 
block t 0 $c $cgoto $c (k_output.status & Fs_Write) == 0  $e 2 $m2 .fp = k_output.fd.fp;
$goto 3 $lbl 2 MUTEX_UNLOCKID(fblk->mutexid);err_msg(
213, NULL);
$efail $lbl 3  $e 
call 1 s fr_e_ t 0 0 4 $c union f (*f)  $e $c &($m2 )  $e $c word status  $e $c $m3  $e $c dptr x  $e $c $r0  $e $c int nargs  $e $c $r1  $e 
$end

$endsect


operators

!	bang	12 1(ud)	{0,*} f_se t 
"!x - generate successive values from object x."
1 blkptr * nil 
4 i $c register C_integer i;  $e j $c register C_integer j;  $e state $c struct hgstate state;  $e ch $c char ch;  $e 
lst if2 && is v 0 is T0 1 
lst abstr nil new T5 1 vartyp 0 
block t 0 $c $m3 = 1;
$lbl 1 $cgoto $c !($r3 <= StrLen($r1 ))  $e 3 $susp T5 3 $c &$m0  $e $c $r3  $e $c (word)1  $e deref(&$m0 , &$m1 );
$cgoto $c !(!(!(($r1 ).dword & F_Nqual)))  $e 4 err_msg(103, &($r1 ));
$efail $lbl 4 $lbl 2 $m3 ++;
$goto 1 $lbl 3  $e 
tcase2 1 6 
1 T2 lst abstr nil . vartyp 1 f 
block t 0 $c ;
$m4 = Blk(BlkD($r1 , Record)->recdesc, Proc)->nfields;
$m3 = 0;
$lbl 8 $cgoto $c !($r3 < $r4 )  $e 10 ;
$susp sv 2 $c &BlkLoc($r1 )->Record.fields[$r3 ]  $e $c BlkD($r1 , Record)  $e $lbl 9 $m3 ++;
$goto 8 $lbl 10  $e 
1 T15 lst abstr nil store . vartyp 1 C8 
block t 0 $c ;
$m2 = hgfirst(BlkLoc($r1 ), &$m5 );
$lbl 11 $cgoto $c !($r2 != 0)  $e 13 ;
$susp d 1 $c $r2 ->Selem.setmem  $e $lbl 12 $m2 = hgnext(BlkLoc($r1 ), &$m5 , $r2 );
$goto 11 $lbl 13  $e 
1 T12 lst abstr nil . vartyp 1 C5 
block t 0 $c ${ struct b_tvtbl *tp;
;
$m2 = hgfirst(BlkLoc($r1 ), &$m5 );
$lbl 14 $cgoto $c !($r2 != 0)  $e 16 ;
$lbl 17 $cgoto $c !((tp = alctvtbl(&$m1 , &$r2 ->Telem.tref, $r2 ->Telem.hashnum)) == NULL)  $e 19 err_msg(0, NULL);
$efail $lbl 19 $cgoto $c 0  $e 17 $lbl 18 $susp T6 1 $c tp  $e $lbl 15 $m2 = hgnext(BlkLoc($r1 ), &$m5 , $r2 );
$goto 14 $lbl 16 $}  $e 
1 T13 lst abstr nil typ T0 
call 0 s f_se_ t 0 0 1 $c dptr dx  $e $c &($r1 )  $e 
1 T11 lst abstr nil . vartyp 1 C3 
block t 1 blkptr $c ;
$m2 = BlkD($r1 , List)->listhead;
$cgoto $c BlkType($r2 ) == T_Realarray  $e 20 $cgoto $c BlkType($r2 ) == T_Intarray  $e 21 $m2 = BlkD($r1 , List)->listhead;
$lbl 22 $cgoto $c !(BlkType($r2 ) == T_Lelem)  $e 24 $m3 = 0;
$lbl 25 $cgoto $c !($r3 < Blk($r2 , Lelem)->nused)  $e 27 $m4 = $r2 ->Lelem.first + $r3 ;
$cgoto $c !($r4 >= $r2 ->Lelem.nslots)  $e 28 $m4 -= $r2 ->Lelem.nslots;
$lbl 28 $susp sv 2 $c &$r2 ->Lelem.lslots[$r4 ]  $e $c $r2  $e $lbl 26 $m3 ++;
$goto 25 $lbl 27 $lbl 23 $m2 = Blk($r2 , Lelem)->listnext;
$goto 22 $lbl 24 $goto 29 $lbl 21 ${ word asize = BlkD($r1 , List)->size;$t0 .vword.bptr = (union block *)
(struct b_intarray *)$r2 ;
$m3 = 0;
$lbl 30 $cgoto $c !($r3 < asize)  $e 32 $susp sv 2 $c &(*(struct b_intarray**)&$t0 .vword.bptr)->a[$r3 ]  $e $c (*(struct b_intarray**)&$t0 .vword.bptr)  $e $lbl 31 $m3 ++;
$goto 30 $lbl 32 $} $lbl 29 $goto 33 $lbl 20 ${ word asize = BlkD($r1 , List)->size;$t0 .vword.bptr = (union block *)
(struct b_realarray *)$r2 ;
$m3 = 0;
$lbl 34 $cgoto $c !($r3 < asize)  $e 36 $susp sv 2 $c &(*(struct b_realarray**)&$t0 .vword.bptr)->a[$r3 ]  $e $c (*(struct b_realarray**)&$t0 .vword.bptr)  $e $lbl 35 $m3 ++;
$goto 34 $lbl 36 $} $lbl 33  $e 
1 T1 lst abstr nil typ T1 
block t 0 $c ${ C_integer from = 1, to;
$cgoto $c !(!cnv_c_int(&($r1 ), &(to)))  $e 37 $fail $lbl 37 $cgoto $c !(to < 1)  $e 38 $fail $lbl 38 ;
$lbl 39 $cgoto $c !(from <= to)  $e 41 $susp ci 1 $c from  $e $lbl 40 from += 1;
$goto 39 $lbl 41 $}  $e 
if2 cnv1 ts 1 
lst abstr nil typ T0 
block t 0 $c $m3 = 1;
$lbl 5 $cgoto $c !($r3 <= StrLen($r1 ))  $e 7 $m6 = *(StrLoc($r1 ) + $r3 - 1);
$susp T0 2 $c 1  $e $c (char *)&allchars[FromAscii($r6 ) & 0xFF]  $e $lbl 6 $m3 ++;
$goto 5 $lbl 7  $e 
runerr2 116 1 
block _ 0 $c $fail  $e 
$end

%	mod	06 2(d,d)	{1,1} _r_e t 
""
2 desc nil desc nil 
1 irslt $c C_integer irslt;  $e 
acase 0 1 
lst abstr nil typ T1 
block _ 0 $c ${ int over_flow = 0;
$m4 = mod3($r0 , $r1 , &over_flow);
$cgoto $c !(over_flow)  $e 0 irunerr(202, $r1 );
$efail $lbl 0 $ret ci 1 $c $r4  $e ;
$}  $e 
lst abstr nil typ T1 
block _ 0 $c $cgoto $c !((Type($r1 ) == T_Integer) && (IntVal($r1 ) == 0))  $e 1 irunerr(202, 0);
$efail $lbl 1 $cgoto $c !(bigmod(&$m0 , &$m1 , &$mr ) == RunError)  $e 2 err_msg(0, NULL);
$efail $lbl 2 $ret rn 0 ;  $e 
lst abstr nil typ T10 
block _ 0 $c ${ double d;
$cgoto $c !($r1 == 0.0)  $e 3 err_msg(204, NULL);
$efail $lbl 3 d = fmod($r0 , $r1 );
$cgoto $c $r0 < 0.0  $e 4 $cgoto $c !(d < 0.0)  $e 5 d += (($r1 ) > 0 ? ($r1 ) : -($r1 ));
$lbl 5 $goto 6 $lbl 4 $cgoto $c !(d > 0.0)  $e 7 d -= (($r1 ) > 0 ? ($r1 ) : -($r1 ));
$lbl 7 $lbl 6 $ret cd 1 $c d  $e $} ;  $e 
$end

&	conj	1d 2(u,u)	{1,1} _r__ f 
"x & y - produce value of y."
0 
0 
lst abstr nil vartyp 1 
block _ 0 $c $ret d 1 $c $r1  $e  $e 
$end

*	size	0x 1(d)	{1,1} _r_e f 
"*x - return size of string or object x."
0 
0 
lst abstr nil typ T1 
tcase2 0 8 
1 T13 block _ 0 $c ${ int status = BlkD($r0 , File)->status;
$cgoto $c !((status & Fs_Dbm) == Fs_Dbm)  $e 0 ${ int count = 0; 
DBM *db = BlkLoc($r0 )->File.fd.dbm; 
datum key = dbm_firstkey(db);
$lbl 1 $cgoto $c !(key.dptr != NULL)  $e 2 count++;
key = dbm_nextkey(db);
$goto 1 $lbl 2 $ret ci 1 $c count  $e $} $lbl 0 err_msg(1100, &($r0 ));
$efail $}  $e 
1 T2 block _ 0 $c ${ C_integer siz; 
union block *bp, *rd;
bp = BlkLoc($r0 );
rd = Blk(bp, Record)->recdesc;
siz = Blk(BlkD($r0 , Record)->recdesc, Proc)->nfields;
$cgoto $c !(Blk(rd, Proc)->ndynam == -3)  $e 3 siz -= 2;
$lbl 3 $ret ci 1 $c siz  $e $}  $e 
1 T4 block _ 0 $c $ret ci 1 $c BlkD($r0 , Coexpr)->size  $e  $e 
1 T9 block _ 0 $c ${ register word i;
i = BlkD($r0 , Cset)->size;
$cgoto $c !(i < 0)  $e 4 i = cssize(&$m0 );
$lbl 4 $ret ci 1 $c i  $e $}  $e 
1 T15 block _ 0 $c $ret ci 1 $c BlkD($r0 , Set)->size  $e  $e 
1 T12 block _ 0 $c $ret ci 1 $c BlkD($r0 , Table)->size  $e  $e 
1 T11 block _ 0 $c $ret ci 1 $c BlkD($r0 , List)->size  $e  $e 
1 T0 block _ 0 $c $ret ci 1 $c StrLen($r0 )  $e  $e 
lst if1 ! cnv1 ts 0 
runerr2 112 0 
block _ 0 $c $ret ci 1 $c StrLen($r0 )  $e  $e 
$end

*	mult	07 2(d,d)	{1,1} _r_e t 
""
2 desc nil desc nil 
1 irslt $c C_integer irslt;  $e 
acase 0 1 
lst abstr nil typ T1 
block _ 0 $c ${ int over_flow = 0;
$m4 = mul($r0 , $r1 , &over_flow);
$cgoto $c over_flow  $e 0 $ret ci 1 $c $r4  $e $goto 1 $lbl 0 MakeInt($r0 , &$m3 );
MakeInt($r1 , &$m2 );
$cgoto $c !(bigmul(&$m3 , &$m2 , &$mr ) == RunError)  $e 2 err_msg(0, NULL);
$efail $lbl 2 $ret rn 0 $lbl 1 ;
$}  $e 
lst abstr nil typ T1 
block _ 0 $c $cgoto $c !(bigmul(&$m0 , &$m1 , &$mr ) == RunError)  $e 3 err_msg(0, NULL);
$efail $lbl 3 $ret rn 0 ;  $e 
lst abstr nil typ T10 
block _ 0 $c ${ double z;
z = $r0 * $r1 ;
$cgoto $c !(isinf(z))  $e 4 err_msg(204, NULL);
$efail $lbl 4 $ret cd 1 $c z  $e $} ;;  $e 
$end

**	inter	18 2(d,d)	{1,1} _r_e f 
"x ** y - intersection of csets, sets or tables x and y."
0 
0 
if2 && is T12 0 is T12 1 
lst abstr nil new T12 3 ** store . vartyp 0 C4 store . vartyp 1 C4 ** store . vartyp 0 C5 store . vartyp 1 C5 store . vartyp 0 C6 
call 0 s _r_e_ t 0 0 2 $c dptr y  $e $c &($r1 )  $e $c dptr x  $e $c &($r0 )  $e 
if2 && is T15 0 is T15 1 
lst abstr nil new T15 1 ** store . vartyp 0 C8 store . vartyp 1 C8 
call 1 s _r_e_ t 0 0 2 $c dptr y  $e $c &($r1 )  $e $c dptr x  $e $c &($r0 )  $e 
lst lst lst if1 ! cnv1 tc 0 
runerr2 120 0 
if1 ! cnv1 tc 1 
runerr2 120 1 
abstr nil typ T9 
call 2 s _r_e_ t 0 0 2 $c dptr y  $e $c &($r1 )  $e $c dptr x  $e $c &($r0 )  $e 
$end

+	number	09 1(d)	{1,1} _r_e f 
"+x - convert x to a number."
0 
0 
if2 cnv1 eci 0 
lst abstr nil typ T1 
block _ 0 $c $ret ci 1 $c $r0  $e  $e 
if2 cnv1 ei 0 
lst abstr nil typ T1 
block _ 0 $c $ret d 1 $c $r0  $e  $e 
if2 cnv1 cd 0 
lst abstr nil typ T10 
block _ 0 $c $ret cd 1 $c $r0  $e  $e 
runerr2 102 0 
$end

+	plus	0a 2(d,d)	{1,1} _r_e t 
""
2 desc nil desc nil 
1 irslt $c C_integer irslt;  $e 
acase 0 1 
lst abstr nil typ T1 
block _ 0 $c ${ int over_flow = 0;
$m4 = add($r0 , $r1 , &over_flow);
$cgoto $c over_flow  $e 0 $ret ci 1 $c $r4  $e $goto 1 $lbl 0 MakeInt($r0 , &$m3 );
MakeInt($r1 , &$m2 );
$cgoto $c !(bigadd(&$m3 , &$m2 , &$mr ) == RunError)  $e 2 err_msg(0, NULL);
$efail $lbl 2 $ret rn 0 $lbl 1 ;
$}  $e 
lst abstr nil typ T1 
block _ 0 $c $cgoto $c !(bigadd(&$m0 , &$m1 , &$mr ) == RunError)  $e 3 err_msg(0, NULL);
$efail $lbl 3 $ret rn 0 ;  $e 
lst abstr nil typ T10 
block _ 0 $c ${ double z;
z = $r0 + $r1 ;
$cgoto $c !(isinf(z))  $e 4 err_msg(204, NULL);
$efail $lbl 4 $ret cd 1 $c z  $e $} ;;  $e 
$end

++	union	19 2(d,d)	{1,1} _r_e t 
"x ++ y - union of csets, sets or tables x and y."
0 
0 
if2 && is T12 0 is T12 1 
lst abstr nil new T12 3 ++ store . vartyp 0 C4 store . vartyp 1 C4 ++ store . vartyp 0 C5 store . vartyp 1 C5 store . vartyp 0 C6 
call 0 s _r_e_ t 0 0 2 $c dptr y  $e $c &($r1 )  $e $c dptr x  $e $c &($m0 )  $e 
if2 && is T15 0 is T15 1 
lst abstr nil new T15 1 ++ store . vartyp 0 C8 store . vartyp 1 C8 
call 1 s _r_e_ t 0 0 2 $c dptr x  $e $c &($m0 )  $e $c dptr y  $e $c &($m1 )  $e 
lst lst lst if1 ! cnv1 tc 0 
runerr2 120 0 
if1 ! cnv1 tc 1 
runerr2 120 1 
abstr nil typ T9 
call 2 s _r_e_ t 0 0 2 $c dptr y  $e $c &($r1 )  $e $c dptr x  $e $c &($r0 )  $e 
$end

-	neg	08 1(d)	{1,1} _r_e t 
"-x - negate x."
0 
0 
if2 cnv1 eci 0 
lst abstr nil typ T1 
block _ 0 $c ${ C_integer i; 
int over_flow = 0;
i = neg($r0 , &over_flow);
$cgoto $c !(over_flow)  $e 0 ${ struct descrip tmp;
MakeInt($r0 , &tmp);
$cgoto $c !(bigneg(&tmp, &$mr ) == RunError)  $e 1 err_msg(0, NULL);
$efail $lbl 1 $ret rn 0 $} $lbl 0 $ret ci 1 $c i  $e $}  $e 
if2 cnv1 ei 0 
lst abstr nil typ T1 
block _ 0 $c $cgoto $c !(bigneg(&$m0 , &$mr ) == RunError)  $e 2 err_msg(0, NULL);
$efail $lbl 2 $ret rn 0  $e 
lst lst if1 ! cnv1 cd 0 
runerr2 102 0 
abstr nil typ T10 
block _ 0 $c ${ double drslt;
drslt = -$r0 ;
$ret cd 1 $c drslt  $e $}  $e 
$end

-	minus	05 2(d,d)	{1,1} _r_e t 
""
2 desc nil desc nil 
1 irslt $c C_integer irslt;  $e 
acase 0 1 
lst abstr nil typ T1 
block _ 0 $c ${ int over_flow = 0;
$m4 = sub($r0 , $r1 , &over_flow);
$cgoto $c over_flow  $e 0 $ret ci 1 $c $r4  $e $goto 1 $lbl 0 MakeInt($r0 , &$m3 );
MakeInt($r1 , &$m2 );
$cgoto $c !(bigsub(&$m3 , &$m2 , &$mr ) == RunError)  $e 2 err_msg(0, NULL);
$efail $lbl 2 $ret rn 0 $lbl 1 ;
$}  $e 
lst abstr nil typ T1 
block _ 0 $c $cgoto $c !(bigsub(&$m0 , &$m1 , &$mr ) == RunError)  $e 3 err_msg(0, NULL);
$efail $lbl 3 $ret rn 0 ;  $e 
lst abstr nil typ T10 
block _ 0 $c ${ double z;
z = $r0 - $r1 ;
$cgoto $c !(isinf(z))  $e 4 err_msg(204, NULL);
$efail $lbl 4 $ret cd 1 $c z  $e $} ;;  $e 
$end

--	diff	17 2(d,d)	{1,1} _r_e f 
"x -- y - difference of csets, sets or tables x and y."
0 
0 
if2 && is T12 0 is T12 1 
lst abstr nil vartyp 0 
call 0 s _r_e_ t 0 0 2 $c dptr y  $e $c &($r1 )  $e $c dptr x  $e $c &($r0 )  $e 
if2 && is T15 0 is T15 1 
lst abstr nil vartyp 0 
call 1 s _r_e_ t 0 0 2 $c dptr y  $e $c &($r1 )  $e $c dptr x  $e $c &($r0 )  $e 
lst lst lst if1 ! cnv1 tc 0 
runerr2 120 0 
if1 ! cnv1 tc 1 
runerr2 120 1 
abstr nil typ T9 
call 2 s _r_e_ t 0 0 2 $c dptr y  $e $c &($r1 )  $e $c dptr x  $e $c &($r0 )  $e 
$end

.	value	1c 1(d)	{1,1} _r__ f 
".x - produce value of x."
0 
0 
lst abstr nil vartyp 0 
block _ 0 $c $ret d 1 $c $r0  $e  $e 
$end

...	to	10 2(d,d)	{0,*} f_se f 
"i to j - generate successive values."
0 
0 
acase 0 1 
lst abstr nil typ T1 
block _ 0 $c ;
$lbl 0 $cgoto $c !($r0 <= $r1 )  $e 2 $susp ci 1 $c $r0  $e $lbl 1 ++$m0 ;
$goto 0 $lbl 2 $fail  $e 
lst abstr nil typ T1 
block _ 2 desc desc $c $t1 = onedesc;;
$lbl 3 $cgoto $c !(bigcmp(&$m0 , &$m1 ) <= 0)  $e 5 $susp d 1 $c $r0  $e bigadd(&$m0 , &$t1 , &$t0 );
$lbl 4 $m0 = $t0 ;
$goto 3 $lbl 5 $fail  $e 
lst abstr nil typ T10 
block _ 0 $c ;
$lbl 6 $cgoto $c !($r0 <= $r1 )  $e 8 $susp cd 1 $c $r0  $e $lbl 7 ++$m0 ;
$goto 6 $lbl 8 $fail  $e 
$end

...	toby	0z 3(d,d,d)	{0,*} f_se f 
"i to j by k - generate successive values."
0 
0 
if2 && cnv1 eci 2 cnv1 eci 0 
lst lst if1 ! cnv1 ci 1 
runerr2 101 1 
abstr nil typ T1 
block _ 0 $c CURTSTATVAR();
$cgoto $c !($r2 == 0)  $e 0 irunerr(211, $r2 );
$efail $lbl 0 $cgoto $c $r2 > 0  $e 1 ;
$lbl 2 $cgoto $c !($r0 >= $r1 )  $e 4 $susp ci 1 $c $r0  $e $lbl 3 $m0 += $r2 ;
$goto 2 $lbl 4 $goto 5 $lbl 1 ;
$lbl 6 $cgoto $c !($r0 <= $r1 )  $e 8 $susp ci 1 $c $r0  $e $lbl 7 $m0 += $r2 ;
$goto 6 $lbl 8 $lbl 5 $fail  $e 
if2 && && cnv1 cd 0 cnv1 cd 1 cnv1 cd 2 
lst abstr nil typ T10 
block _ 0 $c CURTSTATVAR();
$cgoto $c !($r2 == 0)  $e 9 irunerr(211, $r2 );
$efail $lbl 9 $cgoto $c $r2 > 0  $e 10 ;
$lbl 11 $cgoto $c !($r0 >= $r1 )  $e 13 $susp cd 1 $c $r0  $e $lbl 12 $m0 += $r2 ;
$goto 11 $lbl 13 $goto 14 $lbl 10 ;
$lbl 15 $cgoto $c !($r0 <= $r1 )  $e 17 $susp cd 1 $c $r0  $e $lbl 16 $m0 += $r2 ;
$goto 15 $lbl 17 $lbl 14 $fail  $e 
if2 cnv1 ei 2 
acase 0 1 
lst abstr nil typ T1 
block _ 0 $c $fail  $e 
lst abstr nil typ T1 
block _ 0 $c $fail  $e 
lst abstr nil typ T10 
block _ 0 $c $fail  $e 
runerr2 102 2 
$end

/	null	1b 1(ud)	{0,1} fr__ f 
"/x - test x for null value."
0 
0 
lst abstr nil vartyp 0 
if2 is T8 1 
block _ 0 $c $ret d 1 $c $r0  $e  $e 
block _ 0 $c $fail  $e 
$end

/	divide	04 2(d,d)	{1,1} _r_e t 
""
2 desc nil desc nil 
1 irslt $c C_integer irslt;  $e 
acase 0 1 
lst abstr nil typ T1 
block _ 0 $c ${ int over_flow = 0;
$cgoto $c !($r1 == 0)  $e 0 err_msg(201, NULL);
$efail $lbl 0 $m4 = div3($r0 , $r1 , &over_flow);
$cgoto $c over_flow  $e 1 $ret ci 1 $c $r4  $e $goto 2 $lbl 1 MakeInt($r0 , &$m3 );
MakeInt($r1 , &$m2 );
$cgoto $c !(bigdiv(&$m3 , &$m2 , &$mr ) == RunError)  $e 3 err_msg(0, NULL);
$efail $lbl 3 $ret rn 0 $lbl 2 ;
$}  $e 
lst abstr nil typ T1 
block _ 0 $c $cgoto $c !((Type($r1 ) == T_Integer) && (IntVal($r1 ) == 0))  $e 4 err_msg(201, NULL);
$efail $lbl 4 $cgoto $c !(bigdiv(&$m0 , &$m1 , &$mr ) == RunError)  $e 5 err_msg(0, NULL);
$efail $lbl 5 $ret rn 0 ;  $e 
lst abstr nil typ T10 
block _ 0 $c $cgoto $c !($r1 == 0.0)  $e 6 err_msg(204, NULL);
$efail $lbl 6 ${ double z;
z = $r0 / $r1 ;
$cgoto $c !(isinf(z))  $e 7 err_msg(204, NULL);
$efail $lbl 7 $ret cd 1 $c z  $e $} ;
;  $e 
$end

:=	asgn	0c 2(u,d)	{0,1} fr_e f 
"x := y - assign y to x."
0 
0 
lst lst lst lst if1 ! is v 0 
runerr2 111 0 
abstr nil vartyp 0 
call 0 n ____t f 0 0 0 
tcase2 0 9 
1 T21 if1 ! cnv2 T0 1 $c *VarLoc($r0 )  $e 
runerr2 103 1 
1 T17 lst if1 ! cnv2 T0 1 $c *VarLoc($r0 )  $e 
runerr2 103 1 
block t 0 $c k_pos = 1;
;  $e 
1 T18 call 1 s f__et f 0 0 2 $c dptr x  $e $c &($r0 )  $e $c dptr y  $e $c &($r1 )  $e 
1 T16 call 2 s ___et f 0 0 2 $c dptr x  $e $c &($m0 )  $e $c dptr y  $e $c &($r1 )  $e 
1 T20 call 3 s ___et f 0 0 2 $c dptr x  $e $c &($r0 )  $e $c dptr y  $e $c &($r1 )  $e 
1 T19 call 4 n ____t f 0 0 2 $c dptr y  $e $c &($r1 )  $e $c dptr x  $e $c &($r0 )  $e 
1 T7 nil 
1 T6 lst abstr = . store . vartyp 0 C1 C5 vartyp 1 nil 
block t 0 $c $cgoto $c !(tvtbl_asgn(&$m0 , (const dptr)&$r1 ) == RunError)  $e 13 err_msg(0, NULL);
$efail $lbl 13  $e 
1 T5 lst abstr = store . vartyp 0 C0 typ T0 nil 
block t 0 $c $cgoto $c !(subs_asgn(&$m0 , (const dptr)&$r1 ) == RunError)  $e 14 err_msg(0, NULL);
$efail $lbl 14  $e 
lst abstr = vartyp 0 vartyp 1 nil 
block t 2 desc blkptr $c $cgoto $c Offset($r0 ) > 0  $e 1 *(dptr)((word *)VarLoc($r0 ) + Offset($r0 )) = $r1 ;
$goto 2 $lbl 1 $cgoto $c BlkLoc($r0 )->Realarray.title == T_Realarray  $e 3 $cgoto $c BlkLoc($r0 )->Intarray.title == T_Intarray  $e 4 *(dptr)((word *)VarLoc($r0 ) + Offset($r0 )) = $r1 ;
$goto 5 $lbl 4 ${ C_integer ii;
$cgoto $c cnv_ec_int(&($r1 ), &(ii))  $e 6 ${ word i;$t1 .vword.bptr = (union block *)
BlkD($r0 , Intarray)->listp;
i = (Offset($r0 ) * sizeof(word) - sizeof(struct b_intarray) + 
sizeof(word)) / sizeof(word);
$t0 .vword.bptr = (union block *)(*(struct b_list**)&$t1 .vword.bptr);
$t0 .dword = D_List;
$cgoto $c !(arraytolist(&$t0 ) != Succeeded)  $e 7 $fail $lbl 7 *(dptr)(&(*(struct b_list**)&$t1 .vword.bptr)->listhead->Lelem.lslots[i]) = $r1 ;
$} $goto 8 $lbl 6 *((word *)VarLoc($r0 ) + Offset($r0 )) = ii;
$lbl 8 $} $lbl 5 $goto 9 $lbl 3 ${ double yy;
$cgoto $c cnv_c_dbl(&($r1 ), &(yy))  $e 10 ${ word i;$t1 .vword.bptr = (union block *)
BlkD($r0 , Realarray)->listp;
i = (Offset($r0 ) * sizeof(word) - sizeof(struct b_realarray) 
+ sizeof(double)) / sizeof(double);
$t0 .vword.bptr = (union block *)(*(struct b_list**)&$t1 .vword.bptr);
$t0 .dword = D_List;
$cgoto $c !(arraytolist(&$t0 ) != Succeeded)  $e 11 $fail $lbl 11 *(dptr)(&(*(struct b_list**)&$t1 .vword.bptr)->listhead->Lelem.lslots[i]) = $r1 ;
$} $goto 12 $lbl 10 *(double *)((word *)VarLoc($r0 ) + Offset($r0 )) = yy;
$lbl 12 $} $lbl 9 $lbl 2  $e 
block _ 0 $c $cgoto $c !((($r0 ).dword == D_Tvsubs))  $e 15 $ret d 1 $c BlkD($r0 , Tvsubs)->ssvar  $e $lbl 15 $ret d 1 $c $r0  $e  $e 
$end

:=:	swap	0f 2(ud,ud)	{0,1} fr_e f 
"x :=: y - swap values of x and y."
2 blkptr * nil blkptr * nil 
2 adj1 $c word adj1 = 0;  $e adj2 $c word adj2 = 0;  $e 
lst lst lst lst lst lst lst lst lst lst if1 ! is v 0 
runerr2 111 0 
if1 ! is v 2 
runerr2 111 2 
abstr nil vartyp 0 
if1 && is T5 0 is T5 2 
call 0 n ____t f 0 0 6 $c word (*adj2)  $e $c &($m7 )  $e $c word (*adj1)  $e $c &($m6 )  $e $c dptr y  $e $c &($r2 )  $e $c dptr bp_y  $e $c &($md4 )  $e $c dptr x  $e $c &($r0 )  $e $c dptr bp_x  $e $c &($md5 )  $e 
call 1 n ____t f 0 0 0 
tcase2 0 9 
1 T21 if1 ! cnv2 T0 3 $c *VarLoc($r0 )  $e 
runerr2 103 3 
1 T17 lst if1 ! cnv2 T0 3 $c *VarLoc($r0 )  $e 
runerr2 103 3 
block t 0 $c k_pos = 1;
;  $e 
1 T18 call 2 s f__et f 0 0 2 $c dptr x  $e $c &($r0 )  $e $c dptr dy  $e $c &($r3 )  $e 
1 T16 call 3 s ___et f 0 0 2 $c dptr x  $e $c &($m0 )  $e $c dptr dy  $e $c &($r3 )  $e 
1 T20 call 4 s ___et f 0 0 2 $c dptr x  $e $c &($r0 )  $e $c dptr dy  $e $c &($r3 )  $e 
1 T19 call 5 n ____t f 0 0 2 $c dptr dy  $e $c &($r3 )  $e $c dptr x  $e $c &($r0 )  $e 
1 T7 nil 
1 T6 lst abstr = . store . vartyp 0 C1 C5 vartyp 3 nil 
block t 0 $c $cgoto $c !(tvtbl_asgn(&$m0 , (const dptr)&$r3 ) == RunError)  $e 14 err_msg(0, NULL);
$efail $lbl 14  $e 
1 T5 lst abstr = store . vartyp 0 C0 typ T0 nil 
block t 0 $c $cgoto $c !(subs_asgn(&$m0 , (const dptr)&$r3 ) == RunError)  $e 15 err_msg(0, NULL);
$efail $lbl 15  $e 
lst abstr = vartyp 0 vartyp 3 nil 
block t 2 desc blkptr $c $cgoto $c Offset($r0 ) > 0  $e 2 *(dptr)((word *)VarLoc($r0 ) + Offset($r0 )) = $r3 ;
$goto 3 $lbl 2 $cgoto $c BlkLoc($r0 )->Realarray.title == T_Realarray  $e 4 $cgoto $c BlkLoc($r0 )->Intarray.title == T_Intarray  $e 5 *(dptr)((word *)VarLoc($r0 ) + Offset($r0 )) = $r3 ;
$goto 6 $lbl 5 ${ C_integer ii;
$cgoto $c cnv_ec_int(&($r3 ), &(ii))  $e 7 ${ word i;$t1 .vword.bptr = (union block *)
BlkD($r0 , Intarray)->listp;
i = (Offset($r0 ) * sizeof(word) - sizeof(struct b_intarray) + 
sizeof(word)) / sizeof(word);
$t0 .vword.bptr = (union block *)(*(struct b_list**)&$t1 .vword.bptr);
$t0 .dword = D_List;
$cgoto $c !(arraytolist(&$t0 ) != Succeeded)  $e 8 $fail $lbl 8 *(dptr)(&(*(struct b_list**)&$t1 .vword.bptr)->listhead->Lelem.lslots[i]) = $r3 ;
$} $goto 9 $lbl 7 *((word *)VarLoc($r0 ) + Offset($r0 )) = ii;
$lbl 9 $} $lbl 6 $goto 10 $lbl 4 ${ double yy;
$cgoto $c cnv_c_dbl(&($r3 ), &(yy))  $e 11 ${ word i;$t1 .vword.bptr = (union block *)
BlkD($r0 , Realarray)->listp;
i = (Offset($r0 ) * sizeof(word) - sizeof(struct b_realarray) 
+ sizeof(double)) / sizeof(double);
$t0 .vword.bptr = (union block *)(*(struct b_list**)&$t1 .vword.bptr);
$t0 .dword = D_List;
$cgoto $c !(arraytolist(&$t0 ) != Succeeded)  $e 12 $fail $lbl 12 *(dptr)(&(*(struct b_list**)&$t1 .vword.bptr)->listhead->Lelem.lslots[i]) = $r3 ;
$} $goto 13 $lbl 11 *(double *)((word *)VarLoc($r0 ) + Offset($r0 )) = yy;
$lbl 13 $} $lbl 10 $lbl 3  $e 
if1 && is T5 0 is T5 2 
block t 0 $c $cgoto $c !($r7 != 0)  $e 16 Blk($r4 , Tvsubs)->sspos += $r7 ;
$lbl 16  $e 
call 6 n ____t f 0 0 0 
tcase2 2 9 
1 T21 if1 ! cnv2 T0 1 $c *VarLoc($r2 )  $e 
runerr2 103 1 
1 T17 lst if1 ! cnv2 T0 1 $c *VarLoc($r2 )  $e 
runerr2 103 1 
block t 0 $c k_pos = 1;
;  $e 
1 T18 call 7 s f__et f 0 0 2 $c dptr y  $e $c &($r2 )  $e $c dptr dx  $e $c &($r1 )  $e 
1 T16 call 8 s ___et f 0 0 2 $c dptr y  $e $c &($m2 )  $e $c dptr dx  $e $c &($r1 )  $e 
1 T20 call 9 s ___et f 0 0 2 $c dptr y  $e $c &($r2 )  $e $c dptr dx  $e $c &($r1 )  $e 
1 T19 call a n ____t f 0 0 2 $c dptr dx  $e $c &($r1 )  $e $c dptr y  $e $c &($r2 )  $e 
1 T7 nil 
1 T6 lst abstr = . store . vartyp 2 C1 C5 vartyp 1 nil 
block t 0 $c $cgoto $c !(tvtbl_asgn(&$m2 , (const dptr)&$r1 ) == RunError)  $e 29 err_msg(0, NULL);
$efail $lbl 29  $e 
1 T5 lst abstr = store . vartyp 2 C0 typ T0 nil 
block t 0 $c $cgoto $c !(subs_asgn(&$m2 , (const dptr)&$r1 ) == RunError)  $e 30 err_msg(0, NULL);
$efail $lbl 30  $e 
lst abstr = vartyp 2 vartyp 1 nil 
block t 2 desc blkptr $c $cgoto $c Offset($r2 ) > 0  $e 17 *(dptr)((word *)VarLoc($r2 ) + Offset($r2 )) = $r1 ;
$goto 18 $lbl 17 $cgoto $c BlkLoc($r2 )->Realarray.title == T_Realarray  $e 19 $cgoto $c BlkLoc($r2 )->Intarray.title == T_Intarray  $e 20 *(dptr)((word *)VarLoc($r2 ) + Offset($r2 )) = $r1 ;
$goto 21 $lbl 20 ${ C_integer ii;
$cgoto $c cnv_ec_int(&($r1 ), &(ii))  $e 22 ${ word i;$t1 .vword.bptr = (union block *)
BlkD($r2 , Intarray)->listp;
i = (Offset($r2 ) * sizeof(word) - sizeof(struct b_intarray) + 
sizeof(word)) / sizeof(word);
$t0 .vword.bptr = (union block *)(*(struct b_list**)&$t1 .vword.bptr);
$t0 .dword = D_List;
$cgoto $c !(arraytolist(&$t0 ) != Succeeded)  $e 23 $fail $lbl 23 *(dptr)(&(*(struct b_list**)&$t1 .vword.bptr)->listhead->Lelem.lslots[i]) = $r1 ;
$} $goto 24 $lbl 22 *((word *)VarLoc($r2 ) + Offset($r2 )) = ii;
$lbl 24 $} $lbl 21 $goto 25 $lbl 19 ${ double yy;
$cgoto $c cnv_c_dbl(&($r1 ), &(yy))  $e 26 ${ word i;$t1 .vword.bptr = (union block *)
BlkD($r2 , Realarray)->listp;
i = (Offset($r2 ) * sizeof(word) - sizeof(struct b_realarray) 
+ sizeof(double)) / sizeof(double);
$t0 .vword.bptr = (union block *)(*(struct b_list**)&$t1 .vword.bptr);
$t0 .dword = D_List;
$cgoto $c !(arraytolist(&$t0 ) != Succeeded)  $e 27 $fail $lbl 27 *(dptr)(&(*(struct b_list**)&$t1 .vword.bptr)->listhead->Lelem.lslots[i]) = $r1 ;
$} $goto 28 $lbl 26 *(double *)((word *)VarLoc($r2 ) + Offset($r2 )) = yy;
$lbl 28 $} $lbl 25 $lbl 18  $e 
if1 && is T5 0 is T5 2 
block t 0 $c $cgoto $c !($r6 != 0)  $e 31 Blk($r5 , Tvsubs)->sspos += $r6 ;
$lbl 31  $e 
block _ 0 $c $ret d 1 $c $r0  $e  $e 
$end

<	numlt	0m 2(d,d)	{0,1} fr_e f 
"x < y - test if x is numerically less than y."
0 
0 
acase 0 1 
lst abstr nil typ T1 
block _ 0 $c $cgoto $c !($r0 < $r1 )  $e 0 $ret ci 1 $c $r1  $e $lbl 0 $fail  $e 
lst abstr nil typ T1 
block _ 0 $c $cgoto $c !((bigcmp(&$m0 , &$m1 ) < 0))  $e 1 $ret d 1 $c $r1  $e $lbl 1 $fail  $e 
lst abstr nil typ T10 
block _ 0 $c $cgoto $c !($r0 < $r1 )  $e 2 $ret cd 1 $c $r1  $e $lbl 2 $fail  $e 
$end

<-	rasgn	0d 2(ud,d)	{0,1+} f_se f 
"x <- y - assign y to x. Reverses assignment if resumed."
0 
0 
lst lst lst lst lst lst lst if1 ! is v 0 
runerr2 111 0 
abstr nil vartyp 0 
call 0 n ____t f 0 0 0 
tcase2 0 9 
1 T21 if1 ! cnv2 T0 2 $c *VarLoc($r0 )  $e 
runerr2 103 2 
1 T17 lst if1 ! cnv2 T0 2 $c *VarLoc($r0 )  $e 
runerr2 103 2 
block t 0 $c k_pos = 1;
;  $e 
1 T18 call 1 s f__et f 0 0 2 $c dptr x  $e $c &($r0 )  $e $c dptr y  $e $c &($r2 )  $e 
1 T16 call 2 s ___et f 0 0 2 $c dptr x  $e $c &($m0 )  $e $c dptr y  $e $c &($r2 )  $e 
1 T20 call 3 s ___et f 0 0 2 $c dptr x  $e $c &($r0 )  $e $c dptr y  $e $c &($r2 )  $e 
1 T19 call 4 n ____t f 0 0 2 $c dptr y  $e $c &($r2 )  $e $c dptr x  $e $c &($r0 )  $e 
1 T7 nil 
1 T6 lst abstr = . store . vartyp 0 C1 C5 vartyp 2 nil 
block t 0 $c $cgoto $c !(tvtbl_asgn(&$m0 , (const dptr)&$r2 ) == RunError)  $e 14 err_msg(0, NULL);
$efail $lbl 14  $e 
1 T5 lst abstr = store . vartyp 0 C0 typ T0 nil 
block t 0 $c $cgoto $c !(subs_asgn(&$m0 , (const dptr)&$r2 ) == RunError)  $e 15 err_msg(0, NULL);
$efail $lbl 15  $e 
lst abstr = vartyp 0 vartyp 2 nil 
block t 2 desc blkptr $c $cgoto $c Offset($r0 ) > 0  $e 2 *(dptr)((word *)VarLoc($r0 ) + Offset($r0 )) = $r2 ;
$goto 3 $lbl 2 $cgoto $c BlkLoc($r0 )->Realarray.title == T_Realarray  $e 4 $cgoto $c BlkLoc($r0 )->Intarray.title == T_Intarray  $e 5 *(dptr)((word *)VarLoc($r0 ) + Offset($r0 )) = $r2 ;
$goto 6 $lbl 5 ${ C_integer ii;
$cgoto $c cnv_ec_int(&($r2 ), &(ii))  $e 7 ${ word i;$t1 .vword.bptr = (union block *)
BlkD($r0 , Intarray)->listp;
i = (Offset($r0 ) * sizeof(word) - sizeof(struct b_intarray) + 
sizeof(word)) / sizeof(word);
$t0 .vword.bptr = (union block *)(*(struct b_list**)&$t1 .vword.bptr);
$t0 .dword = D_List;
$cgoto $c !(arraytolist(&$t0 ) != Succeeded)  $e 8 $fail $lbl 8 *(dptr)(&(*(struct b_list**)&$t1 .vword.bptr)->listhead->Lelem.lslots[i]) = $r2 ;
$} $goto 9 $lbl 7 *((word *)VarLoc($r0 ) + Offset($r0 )) = ii;
$lbl 9 $} $lbl 6 $goto 10 $lbl 4 ${ double yy;
$cgoto $c cnv_c_dbl(&($r2 ), &(yy))  $e 11 ${ word i;$t1 .vword.bptr = (union block *)
BlkD($r0 , Realarray)->listp;
i = (Offset($r0 ) * sizeof(word) - sizeof(struct b_realarray) 
+ sizeof(double)) / sizeof(double);
$t0 .vword.bptr = (union block *)(*(struct b_list**)&$t1 .vword.bptr);
$t0 .dword = D_List;
$cgoto $c !(arraytolist(&$t0 ) != Succeeded)  $e 12 $fail $lbl 12 *(dptr)(&(*(struct b_list**)&$t1 .vword.bptr)->listhead->Lelem.lslots[i]) = $r2 ;
$} $goto 13 $lbl 11 *(double *)((word *)VarLoc($r0 ) + Offset($r0 )) = yy;
$lbl 13 $} $lbl 10 $lbl 3  $e 
block t 0 $c $susp d 1 $c $r0  $e  $e 
call 5 n ____t f 0 0 0 
tcase2 0 9 
1 T21 if1 ! cnv2 T0 1 $c *VarLoc($r0 )  $e 
runerr2 103 1 
1 T17 lst if1 ! cnv2 T0 1 $c *VarLoc($r0 )  $e 
runerr2 103 1 
block t 0 $c k_pos = 1;
;  $e 
1 T18 call 6 s f__et f 0 0 2 $c dptr x  $e $c &($r0 )  $e $c dptr saved_x  $e $c &($r1 )  $e 
1 T16 call 7 s ___et f 0 0 2 $c dptr x  $e $c &($m0 )  $e $c dptr saved_x  $e $c &($r1 )  $e 
1 T20 call 8 s ___et f 0 0 2 $c dptr x  $e $c &($r0 )  $e $c dptr saved_x  $e $c &($r1 )  $e 
1 T19 call 9 n ____t f 0 0 2 $c dptr saved_x  $e $c &($r1 )  $e $c dptr x  $e $c &($r0 )  $e 
1 T7 nil 
1 T6 lst abstr = . store . vartyp 0 C1 C5 vartyp 1 nil 
block t 0 $c $cgoto $c !(tvtbl_asgn(&$m0 , (const dptr)&$r1 ) == RunError)  $e 28 err_msg(0, NULL);
$efail $lbl 28  $e 
1 T5 lst abstr = store . vartyp 0 C0 typ T0 nil 
block t 0 $c $cgoto $c !(subs_asgn(&$m0 , (const dptr)&$r1 ) == RunError)  $e 29 err_msg(0, NULL);
$efail $lbl 29  $e 
lst abstr = vartyp 0 vartyp 1 nil 
block t 2 desc blkptr $c $cgoto $c Offset($r0 ) > 0  $e 16 *(dptr)((word *)VarLoc($r0 ) + Offset($r0 )) = $r1 ;
$goto 17 $lbl 16 $cgoto $c BlkLoc($r0 )->Realarray.title == T_Realarray  $e 18 $cgoto $c BlkLoc($r0 )->Intarray.title == T_Intarray  $e 19 *(dptr)((word *)VarLoc($r0 ) + Offset($r0 )) = $r1 ;
$goto 20 $lbl 19 ${ C_integer ii;
$cgoto $c cnv_ec_int(&($r1 ), &(ii))  $e 21 ${ word i;$t1 .vword.bptr = (union block *)
BlkD($r0 , Intarray)->listp;
i = (Offset($r0 ) * sizeof(word) - sizeof(struct b_intarray) + 
sizeof(word)) / sizeof(word);
$t0 .vword.bptr = (union block *)(*(struct b_list**)&$t1 .vword.bptr);
$t0 .dword = D_List;
$cgoto $c !(arraytolist(&$t0 ) != Succeeded)  $e 22 $fail $lbl 22 *(dptr)(&(*(struct b_list**)&$t1 .vword.bptr)->listhead->Lelem.lslots[i]) = $r1 ;
$} $goto 23 $lbl 21 *((word *)VarLoc($r0 ) + Offset($r0 )) = ii;
$lbl 23 $} $lbl 20 $goto 24 $lbl 18 ${ double yy;
$cgoto $c cnv_c_dbl(&($r1 ), &(yy))  $e 25 ${ word i;$t1 .vword.bptr = (union block *)
BlkD($r0 , Realarray)->listp;
i = (Offset($r0 ) * sizeof(word) - sizeof(struct b_realarray) 
+ sizeof(double)) / sizeof(double);
$t0 .vword.bptr = (union block *)(*(struct b_list**)&$t1 .vword.bptr);
$t0 .dword = D_List;
$cgoto $c !(arraytolist(&$t0 ) != Succeeded)  $e 26 $fail $lbl 26 *(dptr)(&(*(struct b_list**)&$t1 .vword.bptr)->listhead->Lelem.lslots[i]) = $r1 ;
$} $goto 27 $lbl 25 *(double *)((word *)VarLoc($r0 ) + Offset($r0 )) = yy;
$lbl 27 $} $lbl 24 $lbl 17  $e 
block _ 0 $c $fail  $e 
$end

<->	rswap	0e 2(ud,ud)	{0,1+} f_se f 
"x <-> y - swap values of x and y. Reverses swap if resumed."
2 blkptr * nil blkptr * nil 
2 adj1 $c word adj1 = 0;  $e adj2 $c word adj2 = 0;  $e 
lst lst lst lst lst lst lst lst lst lst lst lst lst lst lst lst lst if1 ! is v 0 
runerr2 111 0 
if1 ! is v 2 
runerr2 111 2 
abstr nil vartyp 0 
if1 && is T5 0 is T5 2 
call 0 n ____t f 0 0 6 $c word (*adj2)  $e $c &($m7 )  $e $c word (*adj1)  $e $c &($m6 )  $e $c dptr y  $e $c &($r2 )  $e $c dptr bp_y  $e $c &($md4 )  $e $c dptr x  $e $c &($r0 )  $e $c dptr bp_x  $e $c &($md5 )  $e 
call 1 n ____t f 0 0 0 
tcase2 0 9 
1 T21 if1 ! cnv2 T0 3 $c *VarLoc($r0 )  $e 
runerr2 103 3 
1 T17 lst if1 ! cnv2 T0 3 $c *VarLoc($r0 )  $e 
runerr2 103 3 
block t 0 $c k_pos = 1;
;  $e 
1 T18 call 2 s f__et f 0 0 2 $c dptr x  $e $c &($r0 )  $e $c dptr dy  $e $c &($r3 )  $e 
1 T16 call 3 s ___et f 0 0 2 $c dptr x  $e $c &($m0 )  $e $c dptr dy  $e $c &($r3 )  $e 
1 T20 call 4 s ___et f 0 0 2 $c dptr x  $e $c &($r0 )  $e $c dptr dy  $e $c &($r3 )  $e 
1 T19 call 5 n ____t f 0 0 2 $c dptr dy  $e $c &($r3 )  $e $c dptr x  $e $c &($r0 )  $e 
1 T7 nil 
1 T6 lst abstr = . store . vartyp 0 C1 C5 vartyp 3 nil 
block t 0 $c $cgoto $c !(tvtbl_asgn(&$m0 , (const dptr)&$r3 ) == RunError)  $e 16 err_msg(0, NULL);
$efail $lbl 16  $e 
1 T5 lst abstr = store . vartyp 0 C0 typ T0 nil 
block t 0 $c $cgoto $c !(subs_asgn(&$m0 , (const dptr)&$r3 ) == RunError)  $e 17 err_msg(0, NULL);
$efail $lbl 17  $e 
lst abstr = vartyp 0 vartyp 3 nil 
block t 2 desc blkptr $c $cgoto $c Offset($r0 ) > 0  $e 4 *(dptr)((word *)VarLoc($r0 ) + Offset($r0 )) = $r3 ;
$goto 5 $lbl 4 $cgoto $c BlkLoc($r0 )->Realarray.title == T_Realarray  $e 6 $cgoto $c BlkLoc($r0 )->Intarray.title == T_Intarray  $e 7 *(dptr)((word *)VarLoc($r0 ) + Offset($r0 )) = $r3 ;
$goto 8 $lbl 7 ${ C_integer ii;
$cgoto $c cnv_ec_int(&($r3 ), &(ii))  $e 9 ${ word i;$t1 .vword.bptr = (union block *)
BlkD($r0 , Intarray)->listp;
i = (Offset($r0 ) * sizeof(word) - sizeof(struct b_intarray) + 
sizeof(word)) / sizeof(word);
$t0 .vword.bptr = (union block *)(*(struct b_list**)&$t1 .vword.bptr);
$t0 .dword = D_List;
$cgoto $c !(arraytolist(&$t0 ) != Succeeded)  $e 10 $fail $lbl 10 *(dptr)(&(*(struct b_list**)&$t1 .vword.bptr)->listhead->Lelem.lslots[i]) = $r3 ;
$} $goto 11 $lbl 9 *((word *)VarLoc($r0 ) + Offset($r0 )) = ii;
$lbl 11 $} $lbl 8 $goto 12 $lbl 6 ${ double yy;
$cgoto $c cnv_c_dbl(&($r3 ), &(yy))  $e 13 ${ word i;$t1 .vword.bptr = (union block *)
BlkD($r0 , Realarray)->listp;
i = (Offset($r0 ) * sizeof(word) - sizeof(struct b_realarray) 
+ sizeof(double)) / sizeof(double);
$t0 .vword.bptr = (union block *)(*(struct b_list**)&$t1 .vword.bptr);
$t0 .dword = D_List;
$cgoto $c !(arraytolist(&$t0 ) != Succeeded)  $e 14 $fail $lbl 14 *(dptr)(&(*(struct b_list**)&$t1 .vword.bptr)->listhead->Lelem.lslots[i]) = $r3 ;
$} $goto 15 $lbl 13 *(double *)((word *)VarLoc($r0 ) + Offset($r0 )) = yy;
$lbl 15 $} $lbl 12 $lbl 5  $e 
if1 && is T5 0 is T5 2 
block t 0 $c $cgoto $c !($r7 != 0)  $e 18 Blk($r4 , Tvsubs)->sspos += $r7 ;
$lbl 18  $e 
call 6 n ____t f 0 0 0 
tcase2 2 9 
1 T21 if1 ! cnv2 T0 1 $c *VarLoc($r2 )  $e 
runerr2 103 1 
1 T17 lst if1 ! cnv2 T0 1 $c *VarLoc($r2 )  $e 
runerr2 103 1 
block t 0 $c k_pos = 1;
;  $e 
1 T18 call 7 s f__et f 0 0 2 $c dptr y  $e $c &($r2 )  $e $c dptr dx  $e $c &($r1 )  $e 
1 T16 call 8 s ___et f 0 0 2 $c dptr y  $e $c &($m2 )  $e $c dptr dx  $e $c &($r1 )  $e 
1 T20 call 9 s ___et f 0 0 2 $c dptr y  $e $c &($r2 )  $e $c dptr dx  $e $c &($r1 )  $e 
1 T19 call a n ____t f 0 0 2 $c dptr dx  $e $c &($r1 )  $e $c dptr y  $e $c &($r2 )  $e 
1 T7 nil 
1 T6 lst abstr = . store . vartyp 2 C1 C5 vartyp 1 nil 
block t 0 $c $cgoto $c !(tvtbl_asgn(&$m2 , (const dptr)&$r1 ) == RunError)  $e 31 err_msg(0, NULL);
$efail $lbl 31  $e 
1 T5 lst abstr = store . vartyp 2 C0 typ T0 nil 
block t 0 $c $cgoto $c !(subs_asgn(&$m2 , (const dptr)&$r1 ) == RunError)  $e 32 err_msg(0, NULL);
$efail $lbl 32  $e 
lst abstr = vartyp 2 vartyp 1 nil 
block t 2 desc blkptr $c $cgoto $c Offset($r2 ) > 0  $e 19 *(dptr)((word *)VarLoc($r2 ) + Offset($r2 )) = $r1 ;
$goto 20 $lbl 19 $cgoto $c BlkLoc($r2 )->Realarray.title == T_Realarray  $e 21 $cgoto $c BlkLoc($r2 )->Intarray.title == T_Intarray  $e 22 *(dptr)((word *)VarLoc($r2 ) + Offset($r2 )) = $r1 ;
$goto 23 $lbl 22 ${ C_integer ii;
$cgoto $c cnv_ec_int(&($r1 ), &(ii))  $e 24 ${ word i;$t1 .vword.bptr = (union block *)
BlkD($r2 , Intarray)->listp;
i = (Offset($r2 ) * sizeof(word) - sizeof(struct b_intarray) + 
sizeof(word)) / sizeof(word);
$t0 .vword.bptr = (union block *)(*(struct b_list**)&$t1 .vword.bptr);
$t0 .dword = D_List;
$cgoto $c !(arraytolist(&$t0 ) != Succeeded)  $e 25 $fail $lbl 25 *(dptr)(&(*(struct b_list**)&$t1 .vword.bptr)->listhead->Lelem.lslots[i]) = $r1 ;
$} $goto 26 $lbl 24 *((word *)VarLoc($r2 ) + Offset($r2 )) = ii;
$lbl 26 $} $lbl 23 $goto 27 $lbl 21 ${ double yy;
$cgoto $c cnv_c_dbl(&($r1 ), &(yy))  $e 28 ${ word i;$t1 .vword.bptr = (union block *)
BlkD($r2 , Realarray)->listp;
i = (Offset($r2 ) * sizeof(word) - sizeof(struct b_realarray) 
+ sizeof(double)) / sizeof(double);
$t0 .vword.bptr = (union block *)(*(struct b_list**)&$t1 .vword.bptr);
$t0 .dword = D_List;
$cgoto $c !(arraytolist(&$t0 ) != Succeeded)  $e 29 $fail $lbl 29 *(dptr)(&(*(struct b_list**)&$t1 .vword.bptr)->listhead->Lelem.lslots[i]) = $r1 ;
$} $goto 30 $lbl 28 *(double *)((word *)VarLoc($r2 ) + Offset($r2 )) = yy;
$lbl 30 $} $lbl 27 $lbl 20  $e 
if1 && is T5 0 is T5 2 
block t 0 $c $cgoto $c !($r6 != 0)  $e 33 Blk($r5 , Tvsubs)->sspos += $r6 ;
$lbl 33  $e 
block t 0 $c $susp d 1 $c $r0  $e  $e 
call b n ____t f 0 0 0 
tcase2 0 9 
1 T21 if1 ! cnv2 T0 1 $c *VarLoc($r0 )  $e 
runerr2 103 1 
1 T17 lst if1 ! cnv2 T0 1 $c *VarLoc($r0 )  $e 
runerr2 103 1 
block t 0 $c k_pos = 1;
;  $e 
1 T18 call c s f__et f 0 0 2 $c dptr x  $e $c &($r0 )  $e $c dptr dx  $e $c &($r1 )  $e 
1 T16 call d s ___et f 0 0 2 $c dptr x  $e $c &($m0 )  $e $c dptr dx  $e $c &($r1 )  $e 
1 T20 call e s ___et f 0 0 2 $c dptr x  $e $c &($r0 )  $e $c dptr dx  $e $c &($r1 )  $e 
1 T19 call f n ____t f 0 0 2 $c dptr dx  $e $c &($r1 )  $e $c dptr x  $e $c &($r0 )  $e 
1 T7 nil 
1 T6 lst abstr = . store . vartyp 0 C1 C5 vartyp 1 nil 
block t 0 $c $cgoto $c !(tvtbl_asgn(&$m0 , (const dptr)&$r1 ) == RunError)  $e 46 err_msg(0, NULL);
$efail $lbl 46  $e 
1 T5 lst abstr = store . vartyp 0 C0 typ T0 nil 
block t 0 $c $cgoto $c !(subs_asgn(&$m0 , (const dptr)&$r1 ) == RunError)  $e 47 err_msg(0, NULL);
$efail $lbl 47  $e 
lst abstr = vartyp 0 vartyp 1 nil 
block t 2 desc blkptr $c $cgoto $c Offset($r0 ) > 0  $e 34 *(dptr)((word *)VarLoc($r0 ) + Offset($r0 )) = $r1 ;
$goto 35 $lbl 34 $cgoto $c BlkLoc($r0 )->Realarray.title == T_Realarray  $e 36 $cgoto $c BlkLoc($r0 )->Intarray.title == T_Intarray  $e 37 *(dptr)((word *)VarLoc($r0 ) + Offset($r0 )) = $r1 ;
$goto 38 $lbl 37 ${ C_integer ii;
$cgoto $c cnv_ec_int(&($r1 ), &(ii))  $e 39 ${ word i;$t1 .vword.bptr = (union block *)
BlkD($r0 , Intarray)->listp;
i = (Offset($r0 ) * sizeof(word) - sizeof(struct b_intarray) + 
sizeof(word)) / sizeof(word);
$t0 .vword.bptr = (union block *)(*(struct b_list**)&$t1 .vword.bptr);
$t0 .dword = D_List;
$cgoto $c !(arraytolist(&$t0 ) != Succeeded)  $e 40 $fail $lbl 40 *(dptr)(&(*(struct b_list**)&$t1 .vword.bptr)->listhead->Lelem.lslots[i]) = $r1 ;
$} $goto 41 $lbl 39 *((word *)VarLoc($r0 ) + Offset($r0 )) = ii;
$lbl 41 $} $lbl 38 $goto 42 $lbl 36 ${ double yy;
$cgoto $c cnv_c_dbl(&($r1 ), &(yy))  $e 43 ${ word i;$t1 .vword.bptr = (union block *)
BlkD($r0 , Realarray)->listp;
i = (Offset($r0 ) * sizeof(word) - sizeof(struct b_realarray) 
+ sizeof(double)) / sizeof(double);
$t0 .vword.bptr = (union block *)(*(struct b_list**)&$t1 .vword.bptr);
$t0 .dword = D_List;
$cgoto $c !(arraytolist(&$t0 ) != Succeeded)  $e 44 $fail $lbl 44 *(dptr)(&(*(struct b_list**)&$t1 .vword.bptr)->listhead->Lelem.lslots[i]) = $r1 ;
$} $goto 45 $lbl 43 *(double *)((word *)VarLoc($r0 ) + Offset($r0 )) = yy;
$lbl 45 $} $lbl 42 $lbl 35  $e 
if1 && is T5 0 is T5 2 
block t 0 $c $cgoto $c !($r7 != 0)  $e 48 Blk($r4 , Tvsubs)->sspos -= $r7 ;
$lbl 48  $e 
call g n ____t f 0 0 0 
tcase2 2 9 
1 T21 if1 ! cnv2 T0 3 $c *VarLoc($r2 )  $e 
runerr2 103 3 
1 T17 lst if1 ! cnv2 T0 3 $c *VarLoc($r2 )  $e 
runerr2 103 3 
block t 0 $c k_pos = 1;
;  $e 
1 T18 call h s f__et f 0 0 2 $c dptr y  $e $c &($r2 )  $e $c dptr dy  $e $c &($r3 )  $e 
1 T16 call i s ___et f 0 0 2 $c dptr y  $e $c &($m2 )  $e $c dptr dy  $e $c &($r3 )  $e 
1 T20 call j s ___et f 0 0 2 $c dptr y  $e $c &($r2 )  $e $c dptr dy  $e $c &($r3 )  $e 
1 T19 call k n ____t f 0 0 2 $c dptr dy  $e $c &($r3 )  $e $c dptr y  $e $c &($r2 )  $e 
1 T7 nil 
1 T6 lst abstr = . store . vartyp 2 C1 C5 vartyp 3 nil 
block t 0 $c $cgoto $c !(tvtbl_asgn(&$m2 , (const dptr)&$r3 ) == RunError)  $e 61 err_msg(0, NULL);
$efail $lbl 61  $e 
1 T5 lst abstr = store . vartyp 2 C0 typ T0 nil 
block t 0 $c $cgoto $c !(subs_asgn(&$m2 , (const dptr)&$r3 ) == RunError)  $e 62 err_msg(0, NULL);
$efail $lbl 62  $e 
lst abstr = vartyp 2 vartyp 3 nil 
block t 2 desc blkptr $c $cgoto $c Offset($r2 ) > 0  $e 49 *(dptr)((word *)VarLoc($r2 ) + Offset($r2 )) = $r3 ;
$goto 50 $lbl 49 $cgoto $c BlkLoc($r2 )->Realarray.title == T_Realarray  $e 51 $cgoto $c BlkLoc($r2 )->Intarray.title == T_Intarray  $e 52 *(dptr)((word *)VarLoc($r2 ) + Offset($r2 )) = $r3 ;
$goto 53 $lbl 52 ${ C_integer ii;
$cgoto $c cnv_ec_int(&($r3 ), &(ii))  $e 54 ${ word i;$t1 .vword.bptr = (union block *)
BlkD($r2 , Intarray)->listp;
i = (Offset($r2 ) * sizeof(word) - sizeof(struct b_intarray) + 
sizeof(word)) / sizeof(word);
$t0 .vword.bptr = (union block *)(*(struct b_list**)&$t1 .vword.bptr);
$t0 .dword = D_List;
$cgoto $c !(arraytolist(&$t0 ) != Succeeded)  $e 55 $fail $lbl 55 *(dptr)(&(*(struct b_list**)&$t1 .vword.bptr)->listhead->Lelem.lslots[i]) = $r3 ;
$} $goto 56 $lbl 54 *((word *)VarLoc($r2 ) + Offset($r2 )) = ii;
$lbl 56 $} $lbl 53 $goto 57 $lbl 51 ${ double yy;
$cgoto $c cnv_c_dbl(&($r3 ), &(yy))  $e 58 ${ word i;$t1 .vword.bptr = (union block *)
BlkD($r2 , Realarray)->listp;
i = (Offset($r2 ) * sizeof(word) - sizeof(struct b_realarray) 
+ sizeof(double)) / sizeof(double);
$t0 .vword.bptr = (union block *)(*(struct b_list**)&$t1 .vword.bptr);
$t0 .dword = D_List;
$cgoto $c !(arraytolist(&$t0 ) != Succeeded)  $e 59 $fail $lbl 59 *(dptr)(&(*(struct b_list**)&$t1 .vword.bptr)->listhead->Lelem.lslots[i]) = $r3 ;
$} $goto 60 $lbl 58 *(double *)((word *)VarLoc($r2 ) + Offset($r2 )) = yy;
$lbl 60 $} $lbl 57 $lbl 50  $e 
if1 && is T5 0 is T5 2 
block t 0 $c $cgoto $c !($r6 != 0)  $e 63 Blk($r5 , Tvsubs)->sspos -= $r6 ;
$lbl 63  $e 
block _ 0 $c $fail  $e 
$end

<<	lexlt	0t 2(d,d)	{0,1} fr_e t 
"x << y - test if x is lexically less than y."
0 
1 temp_str $c int temp_str = 0;  $e 
lst lst lst abstr nil typ T0 
if1 ! cnv1 ts 0 
runerr2 103 0 
if1 ! is T0 1 
if2 cnv1 ts 1 
block t 0 $c $m2 = 1;  $e 
runerr2 103 1 
call 0 s fr_e_ t 0 0 3 $c int temp_str  $e $c $r2  $e $c dptr y  $e $c &($m1 )  $e $c dptr x  $e $c &($m0 )  $e 
$end

<<=	lexle	0s 2(d,d)	{0,1} fr_e t 
"x <<= y - test if x is lexically less than or equal to y."
0 
1 temp_str $c int temp_str = 0;  $e 
lst lst lst abstr nil typ T0 
if1 ! cnv1 ts 0 
runerr2 103 0 
if1 ! is T0 1 
if2 cnv1 ts 1 
block t 0 $c $m2 = 1;  $e 
runerr2 103 1 
call 0 s fr_e_ t 0 0 3 $c int temp_str  $e $c $r2  $e $c dptr y  $e $c &($m1 )  $e $c dptr x  $e $c &($m0 )  $e 
$end

<<@	rcvbk	03 2(d,d)	{0,1} fr_e f 
"x<<@y - blocking receive."
1 blkptr b_list nil 
1 d $c struct descrip d;  $e 
lst lst lst abstr nil typ a 
if1 ! def1 ci 0 $c -1  $e 
runerr2 101 0 
if2 is T11 1 
block t 0 $c $m2 = BlkD($r1 , List);  $e 
if2 is T13 1 
block _ 1 desc $c ${ register word slen, rlen; 
register char *sptr; 
int status; 
char sbuf[MaxReadStr]; 
SOCKET ws;
$cgoto $c !(status & Fs_Socket)  $e 0 StrLen($t0 ) = 0;
$lbl 1 ws = (SOCKET)BlkD($r1 , File)->fd.fd;
DEC_NARTHREADS;
$cgoto $c !((slen = sock_getstrg(sbuf, MaxReadStr, ws)) == -1)  $e 3 INC_NARTHREADS_CONTROLLED;
$fail $lbl 3 INC_NARTHREADS_CONTROLLED;
$cgoto $c !(slen == -3)  $e 4 $fail $lbl 4 $cgoto $c !(slen == 1 && *sbuf == '\n')  $e 5 $goto 2 $lbl 5 rlen = slen < 0 ? (word)MaxReadStr : slen;
$lbl 6 $cgoto $c !((reserve(Strings, rlen)) == NULL)  $e 8 err_msg(0, NULL);
$efail $lbl 8 $cgoto $c 0  $e 6 $lbl 7 $cgoto $c !(StrLen($t0 ) > 0 && !InRange(strbase, StrLoc($t0 ), strfree))  $e 9 $lbl 10 $cgoto $c !((reserve(Strings, StrLen($t0 ) + rlen)) == NULL)  $e 12 err_msg(0, NULL);
$efail $lbl 12 $cgoto $c 0  $e 10 $lbl 11 $lbl 13 $cgoto $c !(((StrLoc($t0 ) = alcstr(StrLoc($t0 ), StrLen($t0 )))) == NULL)  $e 15 err_msg(0, NULL);
$efail $lbl 15 $cgoto $c 0  $e 13 $lbl 14 $lbl 9 $lbl 16 $cgoto $c !((sptr = alcstr(sbuf, rlen)) == NULL)  $e 18 err_msg(0, NULL);
$efail $lbl 18 $cgoto $c 0  $e 16 $lbl 17 $cgoto $c !(StrLen($t0 ) == 0)  $e 19 StrLoc($t0 ) = sptr;
$lbl 19 StrLen($t0 ) += rlen;
$cgoto $c StrLoc($t0 )[StrLen($t0 ) - 1] == '\n'  $e 20 $goto 21 $lbl 20 StrLen($t0 )--;
$goto 2 $lbl 21 $cgoto $c slen > 0  $e 1 $lbl 2 $ret d 1 $c $t0  $e $lbl 0 err_msg(118, &($r1 ));
$efail $}  $e 
runerr2 118 1 
call 0 s fr___ t 0 0 3 $c struct descrip (*d)  $e $c &($m3 )  $e $c dptr hp  $e $c &($rd2 )  $e $c C_integer x  $e $c $r0  $e 
$end

<=	numle	0l 2(d,d)	{0,1} fr_e f 
"x <= y - test if x is numerically less than or equal to y."
0 
0 
acase 0 1 
lst abstr nil typ T1 
block _ 0 $c $cgoto $c !($r0 <= $r1 )  $e 0 $ret ci 1 $c $r1  $e $lbl 0 $fail  $e 
lst abstr nil typ T1 
block _ 0 $c $cgoto $c !((bigcmp(&$m0 , &$m1 ) <= 0))  $e 1 $ret d 1 $c $r1  $e $lbl 1 $fail  $e 
lst abstr nil typ T10 
block _ 0 $c $cgoto $c !($r0 <= $r1 )  $e 2 $ret cd 1 $c $r1  $e $lbl 2 $fail  $e 
$end

<@	rcv	02 2(d,d)	{0,1} fr_e f 
"x<@y - non-blocking receive."
1 blkptr b_list nil 
1 d $c struct descrip d;  $e 
lst lst abstr nil typ a 
if2 is T11 1 
block t 0 $c $m2 = BlkD($r1 , List);  $e 
if2 is T13 1 
block _ 2 desc str $c ${ int status, fd, i = 0;
status = BlkD($r1 , File)->status;
$cgoto $c !(!(status & Fs_Read))  $e 0 err_msg(212, &($r1 ));
$efail $lbl 0 $cgoto $c !(status & Fs_Window)  $e 1 $fail $lbl 1 $cgoto $c !(status & Fs_Pty)  $e 2 ${ struct ptstruct *pt = BlkD($r1 , File)->fd.pt; 
int tb; 
fd_set readset; 
struct timeval tv;$t1 .vword.sptr = 
NULL;
FD_ZERO(&readset);
FD_SET(pt->master_fd, &readset);
tv.tv_sec = tv.tv_usec = 0;
$cgoto $c select(pt->master_fd + 1, &readset, NULL, NULL, &tv) > 0  $e 3 $fail $goto 4 $lbl 3 tb = 1;
$cgoto $c i == 0  $e 5 $cgoto $c !(tb < i)  $e 6 i = tb;
$lbl 6 $goto 7 $lbl 5 i = tb;
$lbl 7 $lbl 8 $cgoto $c !(($t1 .vword.sptr = alcstr(NULL, i)) == NULL)  $e 10 err_msg(0, NULL);
$efail $lbl 10 $cgoto $c 0  $e 8 $lbl 9 DEC_NARTHREADS;
tb = read(pt->master_fd, $t1 .vword.sptr, i);
status = (tb != -1);
INC_NARTHREADS_CONTROLLED;
$cgoto $c !(!status)  $e 11 $fail $lbl 11 StrLoc($t0 ) = $t1 .vword.sptr;
StrLen($t0 ) = tb;
$ret d 1 $c $t0  $e $lbl 4 $} $lbl 2 $cgoto $c !((fd = get_fd($r1 , 0)) < 0)  $e 12 err_msg(174, &($r1 ));
$efail $lbl 12 $cgoto $c !(status & Fs_Buff)  $e 13 err_msg(1048, &($r1 ));
$efail $lbl 13 IntVal(amperErrno) = 0;
$cgoto $c !(u_read(fd, i, status, &$t0 ) == 0)  $e 14 $fail $lbl 14 $ret d 1 $c $t0  $e $}  $e 
runerr2 118 1 
call 0 s fr___ t 0 0 2 $c struct descrip (*d)  $e $c &($m3 )  $e $c dptr hp  $e $c &($rd2 )  $e 
$end

=	tabmat	0y 1(d)	{0,*} f_se f 
"=x - tab(match(x)).  Reverses effects if resumed."
0 
0 
if2 is T14 0 
lst abstr nil typ T0 
call 0 s f_se_ t 0 0 1 $c dptr x  $e $c &($r0 )  $e 
if2 ! cnv1 T0 0 
runerr2 103 0 
lst abstr nil typ T0 
call 1 s f_se_ t 0 0 1 $c dptr x  $e $c &($r0 )  $e 
$end

=	numeq	0i 2(d,d)	{0,1} fr_e f 
"x = y - test if x is numerically equal to y."
0 
0 
acase 0 1 
lst abstr nil typ T1 
block _ 0 $c $cgoto $c !($r0 == $r1 )  $e 0 $ret ci 1 $c $r1  $e $lbl 0 $fail  $e 
lst abstr nil typ T1 
block _ 0 $c $cgoto $c !((bigcmp(&$m0 , &$m1 ) == 0))  $e 1 $ret d 1 $c $r1  $e $lbl 1 $fail  $e 
lst abstr nil typ T10 
block _ 0 $c $cgoto $c !($r0 == $r1 )  $e 2 $ret cd 1 $c $r1  $e $lbl 2 $fail  $e 
$end

==	lexeq	0o 2(d,d)	{0,1} fr_e t 
"x == y - test if x is lexically equal to y."
0 
1 temp_str $c int temp_str = 0;  $e 
lst lst lst abstr nil typ T0 
if1 ! cnv1 ts 0 
runerr2 103 0 
if1 ! is T0 1 
if2 cnv1 ts 1 
block t 0 $c $m2 = 1;  $e 
runerr2 103 1 
call 0 s fr_e_ t 0 0 3 $c int temp_str  $e $c $r2  $e $c dptr y  $e $c &($m1 )  $e $c dptr x  $e $c &($m0 )  $e 
$end

===	eqv	0u 2(d,d)	{0,1} fr__ f 
"x === y - test equivalence of x and y."
0 
0 
lst abstr nil vartyp 1 
block _ 0 $c $cgoto $c equiv(&$m0 , &$m1 )  $e 0 $fail $goto 1 $lbl 0 $ret d 1 $c $r1  $e $lbl 1  $e 
$end

>	numgt	0k 2(d,d)	{0,1} fr_e f 
"x > y - test if x is numerically greater than y."
0 
0 
acase 0 1 
lst abstr nil typ T1 
block _ 0 $c $cgoto $c !($r0 > $r1 )  $e 0 $ret ci 1 $c $r1  $e $lbl 0 $fail  $e 
lst abstr nil typ T1 
block _ 0 $c $cgoto $c !((bigcmp(&$m0 , &$m1 ) > 0))  $e 1 $ret d 1 $c $r1  $e $lbl 1 $fail  $e 
lst abstr nil typ T10 
block _ 0 $c $cgoto $c !($r0 > $r1 )  $e 2 $ret cd 1 $c $r1  $e $lbl 2 $fail  $e 
$end

>=	numge	0j 2(d,d)	{0,1} fr_e f 
"x >= y - test if x is numerically greater than or equal to y."
0 
0 
acase 0 1 
lst abstr nil typ T1 
block _ 0 $c $cgoto $c !($r0 >= $r1 )  $e 0 $ret ci 1 $c $r1  $e $lbl 0 $fail  $e 
lst abstr nil typ T1 
block _ 0 $c $cgoto $c !((bigcmp(&$m0 , &$m1 ) >= 0))  $e 1 $ret d 1 $c $r1  $e $lbl 1 $fail  $e 
lst abstr nil typ T10 
block _ 0 $c $cgoto $c !($r0 >= $r1 )  $e 2 $ret cd 1 $c $r1  $e $lbl 2 $fail  $e 
$end

>>	lexgt	0r 2(d,d)	{0,1} fr_e t 
"x >> y - test if x is lexically greater than y."
0 
1 temp_str $c int temp_str = 0;  $e 
lst lst lst abstr nil typ T0 
if1 ! cnv1 ts 0 
runerr2 103 0 
if1 ! is T0 1 
if2 cnv1 ts 1 
block t 0 $c $m2 = 1;  $e 
runerr2 103 1 
call 0 s fr_e_ t 0 0 3 $c int temp_str  $e $c $r2  $e $c dptr y  $e $c &($m1 )  $e $c dptr x  $e $c &($m0 )  $e 
$end

>>=	lexge	0q 2(d,d)	{0,1} fr_e t 
"x >>= y - test if x is lexically greater than or equal to y."
0 
1 temp_str $c int temp_str = 0;  $e 
lst lst lst abstr nil typ T0 
if1 ! cnv1 ts 0 
runerr2 103 0 
if1 ! is T0 1 
if2 cnv1 ts 1 
block t 0 $c $m2 = 1;  $e 
runerr2 103 1 
call 0 s fr_e_ t 0 0 3 $c int temp_str  $e $c $r2  $e $c dptr y  $e $c &($m1 )  $e $c dptr x  $e $c &($m0 )  $e 
$end

?	random	13 1(ud)	{0,1} fr_e t 
"?x - produce a randomly selected element of x."
0 
0 
if2 && is v 0 is T0 1 
lst abstr nil new T5 1 vartyp 0 
call 0 s fr___ t 0 0 2 $c dptr x  $e $c &($m0 )  $e $c dptr dx  $e $c &($r1 )  $e 
tcase2 1 6 
1 T2 lst abstr nil . vartyp 1 f 
call 2 s fr___ t 0 0 1 $c dptr dx  $e $c &($r1 )  $e 
1 T15 lst abstr nil store . vartyp 1 C8 
call 3 s fr___ t 0 0 1 $c dptr dx  $e $c &($r1 )  $e 
1 T12 lst abstr nil . vartyp 1 C5 
call 4 s fr_e_ t 0 0 1 $c dptr dx  $e $c &($m1 )  $e 
1 T11 lst abstr nil . vartyp 1 C3 
call 5 s fr___ t 0 0 1 $c dptr dx  $e $c &($r1 )  $e 
1 T9 lst lst if1 ! cnv1 ts 1 
nil 
abstr nil typ T0 
call 6 s fr___ t 0 0 1 $c dptr dx  $e $c &($r1 )  $e 
1 T0 lst abstr nil typ T0 
call 7 s fr___ t 0 0 1 $c dptr dx  $e $c &($r1 )  $e 
lst lst if1 ! cnv1 T1 1 
runerr2 113 1 
abstr nil ++ typ T1 typ T10 
call 1 s _r_e_ t 0 0 1 $c dptr dx  $e $c &($m1 )  $e 
$end

@>	snd	00 2(d,d)	{0,1} fr_e f 
"x@>y - non-blocking send."
2 desc nil blkptr b_list nil 
0 
lst lst abstr nil typ T1 
if2 is T11 1 
block t 0 $c $m2 = $r1 ;
$m3 = BlkD($r2 , List);  $e 
if2 is T13 1 
block _ 1 desc $c ${ union f f; 
struct b_file *fblk = BlkD($r1 , File); 
word status = fblk->status;
f.fp = BlkLoc($r1 )->File.fd.fp;
$cgoto $c !(!def_tstr($sb , &($r0 ), &(emptystr), &($t0 )))  $e 0 err_msg(109, &($r0 ));
$efail $lbl 0 $cgoto $c !(status & Fs_Socket)  $e 1 MUTEX_LOCKID_CONTROLLED(fblk->mutexid);
$cgoto $c !(sock_write(f.fd, StrLoc($t0 ), StrLen($t0 )) < 0)  $e 2 MUTEX_UNLOCKID(fblk->mutexid);
$fail $lbl 2 MUTEX_UNLOCKID(fblk->mutexid);
$ret ci 1 $c 1  $e $lbl 1 err_msg(118, &($r1 ));
$efail $}  $e 
runerr2 118 1 
call 0 i _r___ f 0 0 3 $c dptr hp  $e $c &($rd3 )  $e $c dptr x  $e $c &($m0 )  $e $c dptr L  $e $c &($m2 )  $e 
$end

@>>	sndbk	01 2(d,d)	{0,1} fr_e f 
"x@>>y - blocking send."
2 desc nil blkptr b_list nil 
0 
lst lst abstr nil typ T1 
if2 is T11 1 
block t 0 $c $m2 = $r1 ;
$m3 = BlkD($r2 , List);  $e 
if2 is T13 1 
block _ 1 desc $c ${ union f f; 
struct b_file *fblk = BlkD($r1 , File); 
word status = fblk->status;
f.fp = BlkLoc($r1 )->File.fd.fp;
$cgoto $c !(!def_tstr($sb , &($r0 ), &(emptystr), &($t0 )))  $e 0 err_msg(109, &($r0 ));
$efail $lbl 0 $cgoto $c !(status & Fs_Socket)  $e 1 MUTEX_LOCKID_CONTROLLED(fblk->mutexid);
$cgoto $c !(sock_write(f.fd, StrLoc($t0 ), StrLen($t0 )) < 0)  $e 2 MUTEX_UNLOCKID(fblk->mutexid);
$fail $lbl 2 $cgoto $c !(sock_write(f.fd, "\n", 1) < 0)  $e 3 MUTEX_UNLOCKID(fblk->mutexid);
$fail $lbl 3 MUTEX_UNLOCKID(fblk->mutexid);
$ret ci 1 $c 1  $e $lbl 1 err_msg(118, &($r1 ));
$efail $}  $e 
runerr2 106 1 
call 0 i _r___ f 0 0 3 $c dptr hp  $e $c &($rd3 )  $e $c dptr x  $e $c &($m0 )  $e $c dptr L  $e $c &($m2 )  $e 
$end

[...]	llist	11 1(dv)	{1,1} _r_e f 
" [x1, x2, ... ] - create an explicitly specified list."
0 
0 
lst abstr nil new T11 1 vartyp 0 
call 0 s _r_e_ t 0 0 2 $c dptr elems  $e $c $r0  $e $c int n  $e $c $r1  $e 
$end

[:]	sect	14 3(ud,d,d)	{0,1} fr_e t 
"x[i:j] - form a substring or list section of x."
0 
1 use_trap $c int use_trap = 0;  $e 
if2 is T11 1 
lst lst lst abstr nil vartyp 1 
if1 ! cnv1 ci 2 
lst if1 cnv1 T1 2 
block _ 0 $c $fail  $e 
runerr2 101 2 
if1 ! cnv1 ci 3 
lst if1 cnv1 T1 3 
block _ 0 $c $fail  $e 
runerr2 101 3 
call 0 s fr_e_ t 0 0 3 $c C_integer j  $e $c $m3  $e $c dptr dx  $e $c &($m1 )  $e $c C_integer i  $e $c $m2  $e 
lst lst lst if2 && is v 0 is T0 1 
lst abstr nil new T5 1 vartyp 0 
block t 0 $c $m4 = 1;  $e 
if2 cnv1 T0 1 
abstr nil typ T0 
runerr2 110 1 
if1 ! cnv1 ci 2 
lst if1 cnv1 T1 2 
block _ 0 $c $fail  $e 
runerr2 101 2 
if1 ! cnv1 ci 3 
lst if1 cnv1 T1 3 
block _ 0 $c $fail  $e 
runerr2 101 3 
call 1 s fr___ t 0 0 5 $c dptr x  $e $c &($m0 )  $e $c int use_trap  $e $c $r4  $e $c C_integer j  $e $c $m3  $e $c dptr dx  $e $c &($r1 )  $e $c C_integer i  $e $c $m2  $e 
$end

[]	subsc	15 2(ud,d)	{0,1} fr_e t 
"x[y] - access yth character or element of x."
0 
1 use_trap $c int use_trap = 0;  $e 
tcase2 1 4 
1 T2 lst abstr nil . vartyp 1 f 
if2 ! cnv1 ci 2 
call 1 s fr_e_ t 0 0 2 $c dptr dx  $e $c &($r1 )  $e $c dptr y  $e $c &($m2 )  $e 
call 2 s fr___ t 0 0 2 $c C_integer y  $e $c $r2  $e $c dptr dx  $e $c &($r1 )  $e 
1 T12 lst abstr = . vartyp 1 C4 vartyp 2 ++ . vartyp 1 C5 new T6 1 vartyp 1 
call 3 s _r_e_ t 0 0 2 $c dptr dx  $e $c &($m1 )  $e $c dptr y  $e $c &($m2 )  $e 
1 T11 lst lst abstr nil . vartyp 1 C3 
if1 ! cnv1 ci 2 
lst if1 cnv1 T1 2 
block _ 0 $c $fail  $e 
runerr2 101 2 
call 4 s fr___ t 0 0 2 $c C_integer y  $e $c $r2  $e $c dptr dx  $e $c &($r1 )  $e 
1 T13 lst abstr nil ++ typ T0 typ T1 
call 5 s fr_e_ t 0 0 2 $c dptr y  $e $c &($m2 )  $e $c dptr dx  $e $c &($m1 )  $e 
lst lst if2 && is v 0 is T0 1 
lst abstr nil new T5 1 vartyp 0 
block t 0 $c $m3 = 1;  $e 
if2 cnv1 ts 1 
abstr nil typ T0 
runerr2 114 1 
if1 ! cnv1 ci 2 
lst if1 cnv1 T1 2 
block _ 0 $c $fail  $e 
runerr2 101 2 
call 0 s fr___ t 0 0 4 $c dptr x  $e $c &($m0 )  $e $c int use_trap  $e $c $r3  $e $c dptr dx  $e $c &($r1 )  $e $c C_integer y  $e $c $r2  $e 
$end

\	nonnull	1a 1(ud)	{0,1} fr__ f 
"\\x - test x for nonnull value."
0 
0 
lst abstr nil vartyp 0 
if2 is T8 1 
block _ 0 $c $fail  $e 
block _ 0 $c $ret d 1 $c $r0  $e  $e 
$end

^	refresh	0w 1(d)	{1,1} _r_e f 
"^x - create a refreshed copy of a co-expression."
0 
0 
lst lst if1 ! is T4 0 
runerr2 118 0 
abstr nil typ T4 
call 0 s _r_e_ t 0 0 1 $c dptr x  $e $c &($r0 )  $e 
$end

^	powr	0b 2(d,d)	{1,1} _r_e t 
"x ^ y - raise x to the y power."
0 
0 
if2 cnv1 eci 1 
if2 cnv1 ei 0 
lst abstr nil typ T1 
block _ 1 desc $c MakeInt($r1 , &$t0 );
$cgoto $c !(bigpow(&$m0 , &$t0 , &$mr ) == RunError)  $e 0 err_msg(0, NULL);
$efail $lbl 0 $ret rn 0  $e 
lst lst if1 ! cnv1 cd 0 
runerr2 102 0 
abstr nil typ T10 
block _ 0 $c $cgoto $c !(ripow($r0 , $r1 , &$mr ) == RunError)  $e 1 err_msg(0, NULL);
$efail $lbl 1 $ret rn 0  $e 
if2 cnv1 ei 1 
if2 cnv1 ei 0 
lst abstr nil typ T1 
block _ 0 $c $cgoto $c !(bigpow(&$m0 , &$m1 , &$mr ) == RunError)  $e 2 err_msg(0, NULL);
$efail $lbl 2 $ret rn 0  $e 
lst lst if1 ! cnv1 cd 0 
runerr2 102 0 
abstr nil typ T10 
block _ 0 $c $cgoto $c !(bigpowri($r0 , &$m1 , &$mr ) == RunError)  $e 3 err_msg(0, NULL);
$efail $lbl 3 $ret rn 0  $e 
lst lst lst if1 ! cnv1 cd 0 
runerr2 102 0 
if1 ! cnv1 cd 1 
runerr2 102 1 
abstr nil typ T10 
block _ 0 $c ${ double z;
$cgoto $c !($r0 == 0.0 && $r1 < 0.0)  $e 4 err_msg(204, NULL);
$efail $lbl 4 $cgoto $c !($r0 < 0.0)  $e 5 err_msg(206, NULL);
$efail $lbl 5 z = pow($r0 , $r1 );
$cgoto $c !(isinf(z))  $e 6 err_msg(204, NULL);
$efail $lbl 6 $ret cd 1 $c z  $e $}  $e 
$end

||	cater	0g 2(d,d)	{1,1} _r_e t 
"x || y - concatenate strings and patterns x and y."
0 
0 
if2 is T14 0 
lst abstr nil typ T14 
call 0 s _r_e_ t 0 0 2 $c dptr x  $e $c &($r0 )  $e $c dptr y  $e $c &($m1 )  $e 
if2 is T14 1 
lst abstr nil typ T14 
call 1 s _r_e_ t 0 0 2 $c dptr y  $e $c &($r1 )  $e $c dptr x  $e $c &($m0 )  $e 
lst lst lst if1 ! cnv1 T0 0 
runerr2 103 0 
if1 ! cnv1 T0 1 
runerr2 103 1 
abstr nil typ T0 
call 2 s _r_e_ t 0 0 2 $c dptr y  $e $c &($r1 )  $e $c dptr x  $e $c &($r0 )  $e 
$end

|||	lconcat	0h 2(d,d)	{1,1} _r_e f 
"x ||| y - concatenate lists x and y."
0 
0 
lst lst lst if1 ! is T11 0 
runerr2 108 0 
if1 ! is T11 1 
runerr2 108 1 
abstr nil new T11 1 store . ++ vartyp 0 vartyp 1 C3 
call 0 s _r_e_ t 0 0 2 $c dptr y  $e $c &($m1 )  $e $c dptr x  $e $c &($m0 )  $e 
$end

~	compl	16 1(d)	{1,1} _r_e f 
"~x - complement cset x."
0 
0 
lst lst if1 ! cnv1 tc 0 
runerr2 104 0 
abstr nil typ T9 
call 0 s _r_e_ t 0 0 1 $c dptr x  $e $c &($r0 )  $e 
$end

~=	numne	0n 2(d,d)	{0,1} fr_e f 
"x ~= y - test if x is numerically not equal to y."
0 
0 
acase 0 1 
lst abstr nil typ T1 
block _ 0 $c $cgoto $c !($r0 != $r1 )  $e 0 $ret ci 1 $c $r1  $e $lbl 0 $fail  $e 
lst abstr nil typ T1 
block _ 0 $c $cgoto $c !((bigcmp(&$m0 , &$m1 ) != 0))  $e 1 $ret d 1 $c $r1  $e $lbl 1 $fail  $e 
lst abstr nil typ T10 
block _ 0 $c $cgoto $c !($r0 != $r1 )  $e 2 $ret cd 1 $c $r1  $e $lbl 2 $fail  $e 
$end

~==	lexne	0p 2(d,d)	{0,1} fr_e t 
"x ~== y - test if x is lexically not equal to y."
0 
1 temp_str $c int temp_str = 0;  $e 
lst lst lst abstr nil typ T0 
if1 ! cnv1 ts 0 
runerr2 103 0 
if1 ! is T0 1 
if2 cnv1 ts 1 
block t 0 $c $m2 = 1;  $e 
runerr2 103 1 
call 0 s fr_e_ t 0 0 3 $c int temp_str  $e $c $r2  $e $c dptr y  $e $c &($m1 )  $e $c dptr x  $e $c &($m0 )  $e 
$end

~===	neqv	0v 2(d,d)	{0,1} fr__ f 
"x ~=== y - test inequivalence of x and y."
0 
0 
lst abstr nil vartyp 1 
block _ 0 $c $cgoto $c !equiv(&$m0 , &$m1 )  $e 0 $fail $goto 1 $lbl 0 $ret d 1 $c $r1  $e $lbl 1  $e 
$end

$endsect


keywords

allocated	00 0()	{4,4} _rs_ f 
"&allocated - the space used in the storage regions: total, static, string, and block"
0 
0 
lst abstr nil typ T1 
block _ 0 $c $susp ci 1 $c stattotal + strtotal + blktotal  $e $susp ci 1 $c stattotal  $e $susp ci 1 $c strtotal  $e $ret ci 1 $c blktotal  $e  $e 
$end

ascii	1s 0()	{1,1} ____ f 
"&ascii - a cset consisting of the 128 ascii characters"
0 
0 
const T9 '\000\001\002\003\004\005\006\007\010\011\012\013\014\015\016\017\020\021\022\023\024\025\026\027\030\031\032\033\034\035\036\037\040\041\042\043\044\045\046\047\050\051\052\053\054\055\056\057\060\061\062\063\064\065\066\067\070\071\072\073\074\075\076\077\100\101\102\103\104\105\106\107\110\111\112\113\114\115\116\117\120\121\122\123\124\125\126\127\130\131\132\133\134\135\136\137\140\141\142\143\144\145\146\147\150\151\152\153\154\155\156\157\160\161\162\163\164\165\166\167\170\171\172\173\174\175\176\177' 
$end

clock	01 0()	{2,2} f_se f 
"&clock - a string consisting of the current time of day"
0 
0 
lst abstr nil typ T0 
block _ 0 $c ${ int i, tz_sec, offset_hrs; 
time_t t; 
struct tm *ct; 
char sbuf[128], *tmp;
CURTSTATVAR();
time(&t);
ct = localtime(&t);
tz_sec = timezone;
sprintf(sbuf, "%02d:%02d:%02d", ct->tm_hour, ct->tm_min, ct->tm_sec);
$lbl 0 $cgoto $c !((tmp = alcstr(sbuf, (word)8)) == NULL)  $e 2 err_msg(0, NULL);
$efail $lbl 2 $cgoto $c 0  $e 0 $lbl 1 $susp T0 2 $c 8  $e $c tmp  $e offset_hrs = tz_sec / 3600;
$cgoto $c !(ct->tm_isdst)  $e 3 offset_hrs--;
$lbl 3 sprintf(sbuf, "UTC%+d %s", offset_hrs, ct->tm_zone);
i = strlen(sbuf);
$lbl 4 $cgoto $c !((tmp = alcstr(sbuf, i)) == NULL)  $e 6 err_msg(0, NULL);
$efail $lbl 6 $cgoto $c 0  $e 4 $lbl 5 $susp T0 2 $c i  $e $c tmp  $e $fail $}  $e 
$end

col	1a 0()	{1,1} _r_e f 
"&col - mouse horizontal position in text columns."
0 
0 
lst abstr nil typ T16 
block _ 0 $c $cgoto $c ((lastEventWin).dword == D_Null)  $e 0 $ret T16 1 $c &amperCol  $e $goto 1 $lbl 0 err_msg(140, &(lastEventWin));
$efail $lbl 1  $e 
$end

collections	02 0()	{4,4} _rs_ f 
"&collections - the number of collections: total, triggered by static requests triggered by string requests, and triggered by block requests"
0 
0 
lst abstr nil typ T1 
block _ 0 $c CURTSTATVAR();
$susp ci 1 $c coll_tot  $e $susp ci 1 $c coll_stat  $e $susp ci 1 $c coll_str  $e $ret ci 1 $c coll_blk  $e  $e 
$end

control	1f 0()	{0,1} fr_e f 
"&control - null if control key was down on last X event, else failure"
0 
0 
lst abstr nil typ T8 
block _ 0 $c $cgoto $c ((lastEventWin).dword == D_Null)  $e 0 $cgoto $c xmod_control  $e 1 $fail $goto 2 $lbl 1 $ret d 1 $c nulldesc  $e $lbl 2 $goto 3 $lbl 0 err_msg(140, &(lastEventWin));
$efail $lbl 3  $e 
$end

cset	1t 0()	{1,1} ____ f 
"&cset - a cset consisting of all the 256 characters."
0 
0 
const T9 '\0\1\2\3\4\5\6\7\10\11\12\13\14\15\16\17\20\21\22\23\24\25\26\27\30\31\32\33\34\35\36\37\40\41\42\43\44\45\46\47\50\51\52\53\54\55\56\57\60\61\62\63\64\65\66\67\70\71\72\73\74\75\76\77\100\101\102\103\104\105\106\107\110\111\112\113\114\115\116\117\120\121\122\123\124\125\126\127\130\131\132\133\134\135\136\137\140\141\142\143\144\145\146\147\150\151\152\153\154\155\156\157\160\161\162\163\164\165\166\167\170\171\172\173\174\175\176\177\200\201\202\203\204\205\206\207\210\211\212\213\214\215\216\217\220\221\222\223\224\225\226\227\230\231\232\233\234\235\236\237\240\241\242\243\244\245\246\247\250\251\252\253\254\255\256\257\260\261\262\263\264\265\266\267\270\271\272\273\274\275\276\277\300\301\302\303\304\305\306\307\310\311\312\313\314\315\316\317\320\321\322\323\324\325\326\327\330\331\332\333\334\335\336\337\340\341\342\343\344\345\346\347\350\351\352\353\354\355\356\357\360\361\362\363\364\365\366\367\370\371\372\373\374\375\376\377' 
$end

current	03 0()	{1,1} _r__ f 
"&current - the currently active co-expression"
0 
0 
lst abstr nil typ T4 
block _ 0 $c CURTSTATE();
$ret d 1 $c k_current  $e  $e 
$end

date	04 0()	{1,1} _r_e f 
"&date - the current date"
0 
0 
lst abstr nil typ T0 
block _ 0 $c ${ time_t t; 
struct tm *ct; 
char sbuf[36], *tmp;
time(&t);
ct = localtime(&t);
sprintf(sbuf, "%04d/%02d/%02d", 
1900 + ct->tm_year, ct->tm_mon + 1, ct->tm_mday);
$lbl 0 $cgoto $c !((tmp = alcstr(sbuf, (word)10)) == NULL)  $e 2 err_msg(0, NULL);
$efail $lbl 2 $cgoto $c 0  $e 0 $lbl 1 $ret T0 2 $c 10  $e $c tmp  $e $}  $e 
$end

dateline	06 0()	{2,2} f_se f 
"&dateline - current date and time"
0 
0 
lst abstr nil typ T0 
call 0 s f_se_ t 0 0 0 
$end

digits	07 0()	{1,1} ____ f 
"&digits - a cset consisting of the 10 decimal digits"
0 
0 
const T9 '0123456789' 
$end

dump	15 0()	{1,1} _r__ f 
"&dump - variable that controls termination dump."
0 
0 
lst abstr nil typ T16 
block _ 0 $c $ret T16 1 $c &kywd_dmp  $e  $e 
$end

e	08 0()	{1,1} ____ f 
"&e - the base of the natural logarithms"
0 
0 
const T10 2.71828182845904523536028747135266249775724709369996 
$end

errno	18 0()	{1,1} _r__ f 
"&errno - variable containing error number from previous posix command."
0 
0 
lst abstr nil typ T16 
block _ 0 $c CURTSTATE();
$ret T16 1 $c &amperErrno  $e  $e 
$end

error	09 0()	{1,1} _r__ f 
"&error - enable/disable error conversion"
0 
0 
lst abstr nil typ T16 
block _ 0 $c $ret T16 1 $c &kywd_err  $e  $e 
$end

errornumber	0a 0()	{0,1} fr__ f 
"&errornumber - error number of last error converted to failure"
0 
0 
lst abstr nil typ T1 
block _ 0 $c CURTSTATE();
$cgoto $c !(k_errornumber == 0)  $e 0 $fail $lbl 0 $ret ci 1 $c k_errornumber  $e  $e 
$end

errortext	0b 0()	{0,1} _r__ f 
"&errortext - error message of last error converted to failure"
0 
0 
lst abstr nil typ T0 
block _ 0 $c CURTSTATE();
$cgoto $c !(((k_errornumber == 0) && IntVal(amperErrno) == 0) || 
(StrLoc(k_errortext) == NULL))  $e 0 $ret d 1 $c nulldesc  $e $lbl 0 $ret d 1 $c k_errortext  $e  $e 
$end

errorvalue	0c 0()	{0,1} fr__ f 
"&errorvalue - erroneous value of last error converted to failure"
0 
0 
lst abstr nil typ a 
block _ 0 $c CURTSTATE();
$cgoto $c have_errval  $e 0 $fail $goto 1 $lbl 0 $ret d 1 $c k_errorvalue  $e $lbl 1  $e 
$end

errout	0d 0()	{1,1} _r__ f 
"&errout - standard error output."
0 
0 
lst abstr nil typ T13 
block _ 0 $c $ret T13 1 $c &k_errout  $e  $e 
$end

eventcode	0f 0()	{0,1} _r__ f 
"&eventcode - event in monitored program"
0 
0 
lst abstr nil typ T19 
block _ 0 $c $ret T19 1 $c &k_eventcode  $e  $e 
$end

eventsource	0g 0()	{0,1} _r__ f 
"&eventsource - source of events in monitoring program"
0 
0 
lst abstr nil typ T19 
block _ 0 $c $ret T19 1 $c &k_eventsource  $e  $e 
$end

eventvalue	0h 0()	{0,1} _r__ f 
"&eventvalue - value from event in monitored program"
0 
0 
lst abstr nil typ T19 
block _ 0 $c $ret T19 1 $c &k_eventvalue  $e  $e 
$end

fail	0e 0()	{0,0} f___ f 
"&fail - just fail"
0 
0 
lst abstr nil typ e 
block _ 0 $c $fail  $e 
$end

features	0i 0()	{1,*} f_s_ f 
"&features - generate strings identifying features in this version of Icon"
0 
0 
lst abstr nil typ T0 
call 0 s f_s__ t 0 0 0 
$end

file	0j 0()	{1,1} _r_e f 
"&file - name of the source file for the current execution point"
0 
0 
lst abstr nil typ T0 
block _ 0 $c ${ char *s;
CURTSTATE_AND_CE();
$cgoto $c line_info  $e 0 err_msg(402, NULL);
$efail $goto 1 $lbl 0 $ret cs 1 $c file_name  $e $lbl 1 $}  $e 
$end

host	0k 0()	{1,1} _r_e f 
"&host - a string that identifies the host computer Icon is running on."
0 
0 
lst abstr nil typ T0 
block _ 0 $c ${ char sbuf[MaxCvtLen], *tmp; 
int i;
iconhost(sbuf);
i = strlen(sbuf);
$lbl 0 $cgoto $c !((tmp = alcstr(sbuf, i)) == NULL)  $e 2 err_msg(0, NULL);
$efail $lbl 2 $cgoto $c 0  $e 0 $lbl 1 $ret T0 2 $c i  $e $c tmp  $e $}  $e 
$end

input	0l 0()	{1,1} _r__ f 
"&input - the standard input file"
0 
0 
lst abstr nil typ T13 
block _ 0 $c $ret T13 1 $c &k_input  $e  $e 
$end

interval	1e 0()	{1,1} _r_e f 
"&interval - milliseconds since previous event."
0 
0 
lst abstr nil typ T16 
block _ 0 $c $cgoto $c ((lastEventWin).dword == D_Null)  $e 0 $ret T16 1 $c &amperInterval  $e $goto 1 $lbl 0 err_msg(140, &(lastEventWin));
$efail $lbl 1  $e 
$end

lcase	0m 0()	{1,1} ____ f 
"&lcase - a cset consisting of the 26 lower case letters"
0 
0 
const T9 'abcdefghijklmnopqrstuvwxyz' 
$end

ldrag	1o 0()	{1,1} _r__ f 
"&ldrag - left button drag."
0 
0 
lst abstr nil typ T1 
block _ 0 $c $ret ci 1 $c MOUSELEFTDRAG  $e  $e 
$end

letters	0n 0()	{1,1} ____ f 
"&letters - a cset consisting of the 52 letters"
0 
0 
const T9 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz' 
$end

level	0o 0()	{1,1} _r_e f 
"&level - level of procedure call."
0 
0 
lst abstr nil typ T1 
block _ 0 $c CURTSTATE();
$cgoto $c !(!debug_info)  $e 0 err_msg(402, NULL);
$efail $lbl 0 $ret ci 1 $c k_level  $e  $e 
$end

line	0p 0()	{1,1} _r_e f 
"&line - source line number of current execution point"
0 
0 
lst abstr nil typ T1 
block _ 0 $c CURTSTATE_AND_CE();
$cgoto $c line_info  $e 0 err_msg(402, NULL);
$efail $goto 1 $lbl 0 $ret ci 1 $c line_num  $e $lbl 1  $e 
$end

lpress	1i 0()	{1,1} _r__ f 
"&lpress - left button press."
0 
0 
lst abstr nil typ T1 
block _ 0 $c $ret ci 1 $c MOUSELEFT  $e  $e 
$end

lrelease	1l 0()	{1,1} _r__ f 
"&lrelease - left button release."
0 
0 
lst abstr nil typ T1 
block _ 0 $c $ret ci 1 $c MOUSELEFTUP  $e  $e 
$end

main	0q 0()	{1,1} _r__ f 
"&main - the main co-expression."
0 
0 
lst abstr nil typ T4 
block _ 0 $c $ret d 1 $c k_main  $e  $e 
$end

mdrag	1p 0()	{1,1} _r__ f 
"&mdrag - middle button drag."
0 
0 
lst abstr nil typ T1 
block _ 0 $c $ret ci 1 $c MOUSEMIDDRAG  $e  $e 
$end

meta	1h 0()	{0,1} fr_e f 
"&meta - null if meta key was down on last X event, else failure"
0 
0 
lst abstr nil typ T8 
block _ 0 $c $cgoto $c ((lastEventWin).dword == D_Null)  $e 0 $cgoto $c xmod_meta  $e 1 $fail $goto 2 $lbl 1 $ret d 1 $c nulldesc  $e $lbl 2 $goto 3 $lbl 0 err_msg(140, &(lastEventWin));
$efail $lbl 3  $e 
$end

mpress	1j 0()	{1,1} _r__ f 
"&mpress - middle button press."
0 
0 
lst abstr nil typ T1 
block _ 0 $c $ret ci 1 $c MOUSEMID  $e  $e 
$end

mrelease	1m 0()	{1,1} _r__ f 
"&mrelease - middle button release."
0 
0 
lst abstr nil typ T1 
block _ 0 $c $ret ci 1 $c MOUSEMIDUP  $e  $e 
$end

now	05 0()	{1,1} _r__ f 
"&now - the system time"
0 
0 
lst abstr nil typ T1 
block _ 0 $c ${ time_t t;
time(&t);
$ret ci 1 $c t  $e $}  $e 
$end

null	0r 0()	{1,1} _r__ f 
"&null - the null value."
0 
0 
lst abstr nil typ T8 
block _ 0 $c $ret d 1 $c nulldesc  $e  $e 
$end

output	0s 0()	{1,1} _r__ f 
"&output - the standard output file."
0 
0 
lst abstr nil typ T13 
block _ 0 $c $ret T13 1 $c &k_output  $e  $e 
$end

phi	0t 0()	{1,1} ____ f 
"&phi - the golden ratio"
0 
0 
const T10 1.618033988749894848204586834365638117720309180 
$end

pi	0u 0()	{1,1} ____ f 
"&pi - the ratio of circumference to diameter"
0 
0 
const T10 3.14159265358979323846264338327950288419716939937511 
$end

pick	0v 0()	{0,*} f_se f 
"&pick - variable containing the result of 3D selection"
0 
0 
lst abstr nil typ T0 
block _ 0 $c ${ int i, elements; 
struct b_list *namelist; 
struct descrip name;
CURTSTATVAR();
$cgoto $c !(((lastEventWin).dword == D_Null))  $e 0 err_msg(140, &(lastEventWin));
$efail $lbl 0 $cgoto $c !(((amperPick).dword == D_Null))  $e 1 $fail $lbl 1 namelist = BlkD(amperPick, List);
elements = namelist->size;
i = 0;
$lbl 2 $cgoto $c !(i < elements)  $e 4 c_traverse(namelist, &name, i);
$susp d 1 $c name  $e $lbl 3 i++;
$goto 2 $lbl 4 $fail $}  $e 
$end

pos	0w 0()	{1,1} _r__ f 
"&pos - a variable containing the current focus in string scanning."
0 
0 
lst abstr nil typ T18 
block _ 0 $c CURTSTATE();
$ret T18 1 $c &kywd_pos  $e  $e 
$end

progname	0x 0()	{1,1} _r__ f 
"&progname - a variable containing the program name."
0 
0 
lst abstr nil typ T21 
block _ 0 $c $ret T21 1 $c &kywd_prog  $e  $e 
$end

random	0y 0()	{1,1} _r__ f 
"&random - a variable containing the current seed for random operations."
0 
0 
lst abstr nil typ T16 
block _ 0 $c CURTSTATE();
$ret T16 1 $c &kywd_ran  $e  $e 
$end

rdrag	1q 0()	{1,1} _r__ f 
"&rdrag - right button drag."
0 
0 
lst abstr nil typ T1 
block _ 0 $c $ret ci 1 $c MOUSERIGHTDRAG  $e  $e 
$end

regions	0z 0()	{3,3} _rs_ f 
"&regions - generates regions sizes"
0 
0 
lst abstr nil typ T1 
block _ 0 $c ${ word allRegions = 0; 
struct region *rp;
CURTSTATE();
$susp ci 1 $c 0  $e MUTEX_LOCKID(MTX_STRHEAP);
allRegions = (word)((strend) - (strbase));
rp = curstring->next;
$lbl 0 $cgoto $c !(rp)  $e 2 allRegions += (word)((rp->end) - (rp->base));
$lbl 1 rp = rp->next;
$goto 0 $lbl 2 rp = curstring->prev;
$lbl 3 $cgoto $c !(rp)  $e 5 allRegions += (word)((rp->end) - (rp->base));
$lbl 4 rp = rp->prev;
$goto 3 $lbl 5 MUTEX_UNLOCKID(MTX_STRHEAP);
$susp ci 1 $c allRegions  $e MUTEX_LOCKID(MTX_BLKHEAP);
allRegions = (word)((blkend) - (blkbase));
rp = curblock->next;
$lbl 6 $cgoto $c !(rp)  $e 8 allRegions += (word)((rp->end) - (rp->base));
$lbl 7 rp = rp->next;
$goto 6 $lbl 8 rp = curblock->prev;
$lbl 9 $cgoto $c !(rp)  $e 11 allRegions += (word)((rp->end) - (rp->base));
$lbl 10 rp = rp->prev;
$goto 9 $lbl 11 MUTEX_UNLOCKID(MTX_BLKHEAP);
$ret ci 1 $c allRegions  $e $}  $e 
$end

resize	1r 0()	{1,1} _r__ f 
"&resize - window resize."
0 
0 
lst abstr nil typ T1 
block _ 0 $c $ret ci 1 $c RESIZED  $e  $e 
$end

row	1b 0()	{1,1} _r_e f 
"&row - mouse vertical position in text rows."
0 
0 
lst abstr nil typ T16 
block _ 0 $c $cgoto $c ((lastEventWin).dword == D_Null)  $e 0 $ret T16 1 $c &amperRow  $e $goto 1 $lbl 0 err_msg(140, &(lastEventWin));
$efail $lbl 1  $e 
$end

rpress	1k 0()	{1,1} _r__ f 
"&rpress - right button press."
0 
0 
lst abstr nil typ T1 
block _ 0 $c $ret ci 1 $c MOUSERIGHT  $e  $e 
$end

rrelease	1n 0()	{1,1} _r__ f 
"&rrelease - right button release."
0 
0 
lst abstr nil typ T1 
block _ 0 $c $ret ci 1 $c MOUSERIGHTUP  $e  $e 
$end

shift	1g 0()	{0,1} fr_e f 
"&shift - null if shift key was down on last X event, else failure"
0 
0 
lst abstr nil typ T8 
block _ 0 $c $cgoto $c ((lastEventWin).dword == D_Null)  $e 0 $cgoto $c xmod_shift  $e 1 $fail $goto 2 $lbl 1 $ret d 1 $c nulldesc  $e $lbl 2 $goto 3 $lbl 0 err_msg(140, &(lastEventWin));
$efail $lbl 3  $e 
$end

source	10 0()	{1,1} _r__ f 
"&source - the co-expression that invoked the current co-expression."
0 
0 
lst abstr nil typ T4 
block _ 0 $c CURTSTATE();
$ret T4 1 $c topact(BlkD(k_current, Coexpr))  $e  $e 
$end

storage	11 0()	{3,3} _rs_ f 
"&storage - generate the amount of storage used for each region."
0 
0 
lst abstr nil typ T1 
block _ 0 $c ${ word allRegions = 0; 
struct region *rp;
CURTSTATE();
$susp ci 1 $c 0  $e MUTEX_LOCKID(MTX_STRHEAP);
allRegions = (word)((strfree) - (strbase));
rp = curstring->next;
$lbl 0 $cgoto $c !(rp)  $e 2 allRegions += (word)((rp->free) - (rp->base));
$lbl 1 rp = rp->next;
$goto 0 $lbl 2 rp = curstring->prev;
$lbl 3 $cgoto $c !(rp)  $e 5 allRegions += (word)((rp->free) - (rp->base));
$lbl 4 rp = rp->prev;
$goto 3 $lbl 5 MUTEX_UNLOCKID(MTX_STRHEAP);
$susp ci 1 $c allRegions  $e MUTEX_LOCKID(MTX_BLKHEAP);
allRegions = (word)((blkfree) - (blkbase));
rp = curblock->next;
$lbl 6 $cgoto $c !(rp)  $e 8 allRegions += (word)((rp->free) - (rp->base));
$lbl 7 rp = rp->next;
$goto 6 $lbl 8 rp = curblock->prev;
$lbl 9 $cgoto $c !(rp)  $e 11 allRegions += (word)((rp->free) - (rp->base));
$lbl 10 rp = rp->prev;
$goto 9 $lbl 11 MUTEX_UNLOCKID(MTX_BLKHEAP);
$ret ci 1 $c allRegions  $e $}  $e 
$end

subject	12 0()	{1,1} _r__ f 
"&subject - variable containing the current subject of string scanning."
0 
0 
lst abstr nil typ T17 
block _ 0 $c CURTSTATE();
$ret T17 1 $c &k_subject  $e  $e 
$end

time	13 0()	{1,1} _r__ f 
"&time - the elapsed execution time in milliseconds."
0 
0 
lst abstr nil typ T1 
block _ 0 $c $ret ci 1 $c millisec()  $e  $e 
$end

trace	14 0()	{1,1} _r__ f 
"&trace - variable that controls procedure tracing."
0 
0 
lst abstr nil typ T16 
block _ 0 $c $ret T16 1 $c &kywd_trc  $e  $e 
$end

ucase	16 0()	{1,1} ____ f 
"&ucase - a cset consisting of the 26 uppercase characters."
0 
0 
const T9 'ABCDEFGHIJKLMNOPQRSTUVWXYZ' 
$end

version	17 0()	{3,3} _rs_ f 
"&version - strings identifying this version of Unicon."
0 
0 
lst abstr nil typ T0 
block _ 0 $c $susp cs 1 $c "Unicon Version 13.3 (iconc).  November 13, 2022"  $e $susp cs 1 $c "13.2-292-g085896a13-modified"  $e $ret cs 1 $c "master"  $e  $e 
$end

window	19 0()	{1,1} _r__ f 
"&window - variable containing the current graphics rendering context."
0 
0 
lst abstr nil typ T20 
block _ 0 $c $ret T20 1 $c kywd_xwin + XKey_Window  $e  $e 
$end

x	1c 0()	{1,1} _r_e f 
"&x - mouse horizontal position."
0 
0 
lst abstr nil typ T16 
block _ 0 $c $cgoto $c ((lastEventWin).dword == D_Null)  $e 0 $ret T16 1 $c &amperX  $e $goto 1 $lbl 0 err_msg(140, &(lastEventWin));
$efail $lbl 1  $e 
$end

y	1d 0()	{1,1} _r_e f 
"&y - mouse vertical position."
0 
0 
lst abstr nil typ T16 
block _ 0 $c $cgoto $c ((lastEventWin).dword == D_Null)  $e 0 $ret T16 1 $c &amperY  $e $goto 1 $lbl 0 err_msg(140, &(lastEventWin));
$efail $lbl 1  $e 
$end

$endsect


dependencies

cnv.r         cnv.c $end
data.r        data.c $end
def.r         def.c $end
errmsg.r      errmsg.c $end
fconv.r       f_00.c f_01.c f_02.c f_03.c f_04.c f_040.c f_05.c f_06.c $end
fdb.r         f_5e.c f_5f.c f_5g.c f_5h.c f_5i.c f_5j.c f_5k.c $end
fload.r       f_07.c f_070.c fload.c $end
fmath.r       f_08.c f_09.c f_0a.c f_0b.c f_0c.c f_0d.c f_0e.c f_0f.c f_0g.c 
              f_0h.c f_0i.c f_0j.c f_0j0.c f_0k.c f_0k0.c f_0l.c f_0l0.c $end
fmisc.r       f_0m.c f_0n.c f_0n0.c f_0o.c f_0o0.c f_0p.c f_0p0.c f_0p1.c 
              f_0p2.c f_0p3.c f_0q.c f_0q0.c f_0r.c f_0r0.c f_0s.c f_0t.c 
              f_0u.c f_0v.c f_0w.c f_0w0.c f_0x.c f_0x0.c f_0y.c f_0y0.c f_0z.c 
              f_0z0.c f_10.c f_100.c f_11.c f_110.c f_12.c f_120.c f_13.c 
              f_14.c f_140.c f_141.c f_142.c f_143.c f_15.c f_150.c f_151.c 
              f_152.c f_16.c f_17.c f_170.c f_18.c f_180.c f_19.c f_190.c 
              f_191.c f_1a.c f_1b.c f_1c.c f_1d.c f_1e.c f_1f.c f_1g.c f_1h.c 
              fmisc.c $end
fscan.r       f_1i.c f_1i0.c f_1j.c f_1j0.c f_1k.c f_1k0.c $end
fstr.r        f_1l.c f_1l0.c f_1m.c f_1m0.c f_1n.c f_1n0.c f_1o.c f_1o0.c 
              f_1p.c f_1p0.c f_1q.c f_1q0.c f_1q1.c f_1r.c f_1r0.c f_1r1.c 
              f_1s.c f_1s0.c f_1t.c f_1t0.c fstr.c $end
fstranl.r     f_1u.c f_1u0.c f_1v.c f_1v0.c f_1w.c f_1w0.c f_1x.c f_1x0.c 
              f_1y.c f_1y0.c f_1z.c f_1z0.c $end
fstruct.r     f_20.c f_200.c f_201.c f_202.c f_203.c f_21.c f_210.c f_211.c 
              f_22.c f_220.c f_221.c f_23.c f_24.c f_240.c f_241.c f_242.c 
              f_243.c f_25.c f_250.c f_26.c f_260.c f_261.c f_27.c f_270.c 
              f_28.c f_280.c f_281.c f_29.c f_290.c f_2a.c f_2a0.c f_2b.c 
              f_2b0.c f_2b1.c f_2c.c f_2c0.c f_2c1.c f_2d.c f_2d0.c f_2e.c 
              f_2e0.c f_2f.c f_2f0.c f_2g.c f_2g0.c f_2h.c f_2i.c f_2j.c 
              f_2j0.c fstruct.c $end
fsys.r        f_2k.c f_2k0.c f_2l.c f_2m.c f_2n.c f_2n0.c f_2o.c f_2o0.c f_2p.c 
              f_2p0.c f_2q.c f_2r.c f_2r0.c f_2s.c f_2s0.c f_2t.c f_2t0.c 
              f_2u.c f_2u0.c f_2v.c f_2v0.c f_2v1.c f_2w.c f_2w0.c f_2w1.c 
              f_2x.c f_2x0.c f_2x1.c f_2y.c f_2y0.c f_2z.c f_2z0.c f_30.c 
              f_31.c f_310.c f_32.c f_33.c f_330.c $end
fwindow.r     f_34.c f_340.c f_35.c f_350.c f_36.c f_360.c f_37.c f_370.c 
              f_38.c f_380.c f_39.c f_390.c f_3a.c f_3a0.c f_3b.c f_3b0.c 
              f_3c.c f_3c0.c f_3d.c f_3d0.c f_3e.c f_3e0.c f_3f.c f_3f0.c 
              f_3g.c f_3g0.c f_3h.c f_3h0.c f_3i.c f_3i0.c f_3j.c f_3j0.c 
              f_3k.c f_3k0.c f_3l.c f_3l0.c f_3m.c f_3m0.c f_3n.c f_3n0.c 
              f_3o.c f_3o0.c f_3p.c f_3p0.c f_3q.c f_3q0.c f_3r.c f_3r0.c 
              f_3s.c f_3s0.c f_3t.c f_3t0.c f_3u.c f_3u0.c f_3v.c f_3v0.c 
              f_3w.c f_3w0.c f_3x.c f_3x0.c f_3y.c f_3y0.c f_3z.c f_3z0.c 
              f_40.c f_400.c f_41.c f_410.c f_42.c f_420.c f_43.c f_430.c 
              f_44.c f_440.c f_45.c f_450.c f_46.c f_460.c f_47.c f_470.c 
              f_48.c f_480.c f_49.c f_490.c f_4a.c f_4a0.c f_4b.c f_4b0.c 
              f_4c.c f_4c0.c f_4d.c f_4d0.c f_4e.c f_4e0.c f_4f.c f_4f0.c 
              f_4g.c f_4h.c f_4i.c f_4j.c f_4k.c f_4l.c f_4m.c f_4n.c f_4o.c 
              f_4p.c f_4q.c f_4r.c f_4r0.c f_4s.c f_4s0.c f_4t.c f_4t0.c f_4u.c 
              f_4u0.c f_4v.c f_4v0.c f_4w.c f_4w0.c f_4x.c f_4x0.c f_4y.c 
              f_4y0.c f_4z.c f_4z0.c f_50.c f_500.c f_51.c f_510.c f_52.c 
              f_520.c f_53.c f_530.c f_54.c f_540.c f_55.c f_550.c f_56.c 
              f_560.c f_57.c f_570.c f_58.c f_580.c f_59.c f_590.c f_5a.c 
              f_5a0.c f_5b.c f_5b0.c f_5c.c f_5c0.c f_5d.c f_5d0.c $end
fxtra.r       f_5m.c f_5n.c f_5n0.c f_5o.c f_5p.c f_5q.c f_5r.c f_5r0.c f_5s.c 
              f_5s0.c f_5t.c f_5t0.c f_5u.c f_5u0.c f_5u1.c f_5u2.c f_5u3.c 
              f_5u4.c f_5u5.c f_5u6.c f_5u7.c f_5v.c f_5v0.c f_5v1.c f_5w.c 
              f_5x.c f_5y.c f_5y0.c f_5z.c f_5z0.c f_5z1.c f_60.c f_600.c 
              f_61.c f_610.c f_62.c f_620.c f_63.c f_64.c f_640.c f_65.c 
              f_650.c f_66.c f_67.c f_670.c f_68.c f_680.c f_69.c f_690.c 
              f_6a.c f_6a0.c f_6b.c f_6b0.c f_6c.c f_6c0.c f_6d.c f_6e.c f_6f.c 
              f_6g.c f_6h.c f_6i.c f_6i0.c f_6i1.c f_6j.c f_6j0.c f_6k.c f_6l.c 
              f_6m.c f_6m0.c f_6n.c f_6n0.c f_6o.c f_6o0.c f_6p.c f_6p0.c 
              f_6p1.c f_6q.c f_6q0.c f_6r.c f_6r0.c f_6s.c f_6s0.c f_6t.c 
              f_6t0.c f_6u.c f_6u0.c f_6u1.c f_6u2.c f_6v.c f_6v0.c f_6v1.c 
              f_6v2.c f_6w.c f_6w0.c f_6w1.c f_6w2.c f_6x.c f_6x0.c f_6x1.c 
              f_6x2.c f_6y.c f_6y0.c f_6z.c f_6z0.c f_70.c f_700.c f_71.c 
              f_710.c f_72.c f_720.c f_73.c f_730.c f_74.c f_75.c f_76.c f_77.c 
              f_78.c f_780.c f_79.c f_790.c f_7a.c f_7a0.c f_7b.c f_7b0.c 
              f_7c.c f_7c0.c f_7d.c f_7d0.c f_7e.c f_7e0.c f_7f.c f_7f0.c 
              f_7f1.c f_7g.c f_7g0.c f_7g1.c f_7h.c f_7h0.c f_7h1.c f_7i.c 
              f_7i0.c f_7i1.c f_7j.c f_7j0.c f_7j1.c f_7k.c f_7k0.c f_7l.c 
              f_7l0.c f_7m.c f_7m0.c f_7n.c f_7n0.c f_7o.c f_7o0.c f_7p.c 
              f_7p0.c f_7q.c f_7q0.c f_7r.c f_7r0.c f_7s.c f_7s0.c f_7t.c 
              f_7t0.c f_7u.c f_7u0.c f_7v.c f_7v0.c f_7w.c f_7w0.c f_7x.c 
              f_7x0.c f_7x1.c f_7y.c f_7y0.c f_7z.c f_7z0.c f_80.c f_800.c 
              f_81.c f_810.c fxtra.c $end
init.r        init.c $end
invoke.r      invoke.c $end
keyword.r     k_060.c k_0i0.c keyword.c $end
lmisc.r       o_00.c o_000.c o_01.c o_010.c o_02.c o_020.c o_03.c o_030.c 
              lmisc.c $end
oarith.r      o_04.c o_05.c o_06.c o_07.c o_08.c o_09.c o_0a.c o_0b.c oarith.c 
            $end
oasgn.r       o_0c.c o_0c0.c o_0c1.c o_0c2.c o_0c3.c o_0c4.c o_0d.c o_0d0.c 
              o_0d1.c o_0d2.c o_0d3.c o_0d4.c o_0d5.c o_0d6.c o_0d7.c o_0d8.c 
              o_0d9.c o_0e.c o_0e0.c o_0e1.c o_0e2.c o_0e3.c o_0e4.c o_0e5.c 
              o_0e6.c o_0e7.c o_0e8.c o_0e9.c o_0ea.c o_0eb.c o_0ec.c o_0ed.c 
              o_0ee.c o_0ef.c o_0eg.c o_0eh.c o_0ei.c o_0ej.c o_0ek.c o_0f.c 
              o_0f0.c o_0f1.c o_0f2.c o_0f3.c o_0f4.c o_0f5.c o_0f6.c o_0f7.c 
              o_0f8.c o_0f9.c o_0fa.c oasgn.c $end
ocat.r        o_0g.c o_0g0.c o_0g1.c o_0g2.c o_0h.c o_0h0.c $end
ocomp.r       o_0i.c o_0j.c o_0k.c o_0l.c o_0m.c o_0n.c o_0o.c o_0o0.c o_0p.c 
              o_0p0.c o_0q.c o_0q0.c o_0r.c o_0r0.c o_0s.c o_0s0.c o_0t.c 
              o_0t0.c o_0u.c o_0v.c $end
omisc.r       o_0w.c o_0w0.c o_0x.c o_0y.c o_0y0.c o_0y1.c o_0z.c o_10.c o_11.c 
              o_110.c $end
oref.r        o_12.c o_120.c o_13.c o_130.c o_131.c o_132.c o_133.c o_134.c 
              o_135.c o_136.c o_137.c o_14.c o_140.c o_141.c o_15.c o_150.c 
              o_151.c o_152.c o_153.c o_154.c o_155.c $end
oset.r        o_16.c o_160.c o_17.c o_170.c o_171.c o_172.c o_18.c o_180.c 
              o_181.c o_182.c o_19.c o_190.c o_191.c o_192.c $end
ovalue.r      o_1a.c o_1b.c o_1c.c o_1d.c $end
ralc.r        ralc.c $end
rcoexpr.r     rcoexpr.c $end
rcomp.r       rcomp.c $end
rdebug.r      f_5l.c f_5l0.c rdebug.c $end
rlocal.r      rlocal.c $end
rlrgint.r     rlrgint.c $end
rmemmgt.r     rmemmgt.c $end
rmisc.r       rmisc.c $end
rmsg.r        rmsg.c $end
rposix.r      rposix.c $end
rstruct.r     rstruct.c $end
rsys.r        rsys.c $end
rwindow.r     rwindow.c $end
rwinrsc.r     rwinrsc.c $end
rwinsys.r     rwinsys.c $end

$endsect
